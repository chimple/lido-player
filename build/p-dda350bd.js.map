{"version":3,"names":["DragSelectedMapKey","SelectedValuesKey","ActivityScoreKey","ActivityEndKey","LessonEndKey","NextContainerKey","ActivityChangeKey","GameCompletedKey","ElementDropKey","ElementClickKey","DropLength","DropHasDrag","TraceMode","GameScore","constructor","this","rightMoves","wrongMoves","finalScore","dispatchCustomEvent","eventName","detail","event","CustomEvent","window","dispatchEvent","dispatchActivityEndEvent","index","totalIndex","score","dispatchLessonEndEvent","dispatchNextContainerEvent","dispatchGameCompletedEvent","dispatchActivityChangeEvent","dispatchElementDropEvent","dragElement","dropElement","isCorrect","createdAt","Date","toISOString","dispatchClickEvent","element","RiveService","getInstance","instance","setRiveInstance","riveInstance","getRiveInstance","AudioPlayer","audioElement","document","createElement","id","body","appendChild","getI","stop","speechSynthesis","cancel","pause","currentTime","src","highlightedElements","querySelectorAll","forEach","stopHighlightForSpeakingElement","playElement","querySelector","pauseElement","style","visibility","play","targetElement","audioUrl","getAttribute","childElements","children","i","length","childAudioUrl","convertUrlToRelative","console","log","highlightSpeakingElement","Promise","resolve","onended","error","textContent","speakText","gameScore","format","first","middle","last","getElementScale","el","animation","transform","getComputedStyle","matrix","match","matrixValues","split","scaleX","parseFloat","slidingWithScaling","overlapElement","isDragging","startX","startY","initialX","initialY","parentElement","onStart","removeHighlight","MouseEvent","clientX","clientY","touches","opacity","cursor","getBoundingClientRect","addEventListener","onMove","onEnd","observer","MutationObserver","mutationsList","mutation","type","attributeName","observerConfig","attributes","attributeFilter","observe","parentElementScale","dx","dy","newLeft","newTop","containerRect","elementRect","numbers","result","map","Number","initialElementLeftPx","left","initialElementTopPx","top","initialElementRightPx","right","initialElementBottomPx","bottom","maxRight","maxLeft","maxTop","maxBottom","newLeftClamp","Math","min","newTopClamp","mostOverlappedElement","findMostoverlappedElement","parent1","parent2","elementPlaceholder","createComment","overlappedPlaceholder","replaceChild","endEv","removeEventListener","slideCompleted","ev","onClickDropOrDragElement","slideElement","slideArr","JSON","parse","localStorage","getItem","allSlideElements","item","setItem","stringify","objectiveString","objectiveArray","elementIndex","indexOf","matchStringPattern","trim","storingEachActivityScore","handleShowCheck","enableDraggingWithScaling","isClicked","container","handlingElementFlexibleWidth","verticalDistance","horizontalDistance","rect1","rect2","transition","containerScale","width","abs","height","allElements","otherElement","dropObject","storedTabIndexes","Object","keys","includes","tagName","toLowerCase","border","backgroundColor","onElementDropComplete","maxOverlapArea","otherRect","overlapWidth","max","overlapHeight","overlapArea","elementArea","otherArea","minRequiredOverlap","async","selectedValueData","dragSelectedData","dropHasDrag","isisFull","values","find","getElementById","drop","isFull","dragSelected","key","currentDrop","dragToDropMap","get","prevDropItem","selectedValue","filter","value","dropLength","countPatternWords","set","onCorrect","executeActions","onInCorrect","onActivityComplete","actionsString","thisElement","actions","parseActions","action","queriedElement","actor","currentTransform","dropRect","dragRect","dropCenterX","dropCenterY","dragCenterX","dragCenterY","scaledLeft","scaledTop","classList","add","isNumber","isNaN","setTimeout","riveService","input","actionStrings","_a","actionString","actorAction","part","lastDotIndex","lastIndexOf","substring","push","replace","pattern","arr","patternGroups","group","arrIndex","options","Set","startsWith","endsWith","choices","slice","option","arrChoice","choice","has","delete","wordCount","isAllowOnlyCorrect","dragScore","tabindex","sortedKeys","sort","a","b","parseInt","sortedValues","reduce","acc","join","flag","calculateScore","floor","storeActivityScore","appHome","_b","activityScore","_c","activityScoreKey","toString","scoresArray","cur","removeItem","selectValues","checkButton","showCheck","remove","validateObjectiveStatus","res","appendingDragElementsInDrop","triggerNextContainer","isContinueOnCorrect","dragItems","dropItems","drag","initEventsForElement","onEntry","canplay","addClickListenerForClickType","handleDropElement","onTouchListenerForOnTouch","onTouch","onclick","onClick","objective","isActivated","contains","pointerEvents","multiOptionScore","valueToRemove","keyToRemove","concat","valueToFind","dropHas","tabIndex","innerHTML","head","ariaPressed","selectedDropElement","selectedDragElement","onClickDragElement","translateX","translateY","Map","dropElements","dragEl","firstFalse","dropEl","styleId","url","baseUrl","getAssetPath","text","reject","Error","synth","utterance","SpeechSynthesisUtterance","onend","speak","handlingChildElements","minLength","maxLength","currentLength","displayStyle","undefined","Array","from","allowedLength","child","display","parseProp","propValue","orientation","parsedValues","pair","dragElements","clickElements","maxWidth","clickEl","childEl","originalWidth","originalPadding","padding","tempWidth","offsetWidth","dragItem","isFlexible","dropItem","borderWidth","currentWidth","currentHeight"],"sources":["src/utils/constants.ts","src/utils/customEvents.ts","src/utils/rive-service.ts","src/utils/audioPlayer.ts","src/utils/utils.ts"],"sourcesContent":["export const DragSelectedMapKey = 'lidoDragSelectedMap';\nexport const SelectedValuesKey = 'lidoSelectedValues';\nexport const ActivityScoreKey = 'lidoActivityScore';\nexport const ActivityEndKey = 'lidoActivityEnd';\nexport const LessonEndKey = 'lidoLessonEnd';\nexport const NextContainerKey = 'lidoNextContainer';\nexport const ActivityChangeKey = 'lidoActivityChange';\nexport const GameCompletedKey = 'lidoGameCompleted';\nexport const GameExitKey = 'lidoGameExit';\nexport const ElementDropKey = 'lidoElementDrop';\nexport const ElementClickKey = 'lidoElementClick';\nexport const DropLength = 'dropLength';\nexport const DropHasDrag = 'dropHasDrag';\n\nexport enum TraceMode {\n  NoFlow = 'lido-noFlow',\n  ShowFlow = 'lido-showFlow',\n  FreeTrace = 'lido-freeTrace',\n  BlindTracing = 'lido-blindTracing',\n  BlindFreeTrace = 'lido-blindFreeTrace',\n}\n\nexport default class GameScore{\n  rightMoves: number = 0;\n  wrongMoves: number = 0;\n  finalScore: number = 0;\n}\n","import { ActivityChangeKey, ActivityEndKey, ElementClickKey, ElementDropKey, GameCompletedKey, GameExitKey, LessonEndKey, NextContainerKey } from './constants';\n\nfunction dispatchCustomEvent(eventName: string, detail: any) {\n  const event = new CustomEvent(eventName, { detail });\n  window.dispatchEvent(event);\n}\n\nexport function dispatchActivityEndEvent(index: number, totalIndex: number, score: number) {\n  dispatchCustomEvent(ActivityEndKey, { index, totalIndex, score });\n}\n\nexport function dispatchLessonEndEvent(score: number) {\n  dispatchCustomEvent(LessonEndKey, { score });\n}\n\nexport function dispatchNextContainerEvent() {\n  dispatchCustomEvent(NextContainerKey, {});\n}\n\nexport function dispatchGameCompletedEvent() {\n  dispatchCustomEvent(GameCompletedKey, {});\n}\n\nexport function dispatchGameExitEvent() {\n  dispatchCustomEvent(GameExitKey, {});\n}\n\nexport function dispatchActivityChangeEvent(index: number) {\n  dispatchCustomEvent(ActivityChangeKey, { index });\n}\n\nexport function dispatchElementDropEvent(dragElement: HTMLElement, dropElement: HTMLElement, isCorrect: boolean) {\n  dispatchCustomEvent(ElementDropKey, { dragElement, dropElement, isCorrect: isCorrect, createdAt: new Date().toISOString() });\n}\n\nexport function dispatchClickEvent(element: HTMLElement, isCorrect: boolean) {\n  dispatchCustomEvent(ElementClickKey, { element, isCorrect: isCorrect, createdAt: new Date().toISOString() });\n}\n","// rive-service.ts\nexport class RiveService {\n  private static instance: RiveService;\n  public riveInstance: any;\n\n  private constructor() {}\n\n  public static getInstance() {\n    if (!RiveService.instance) {\n      RiveService.instance = new RiveService();\n    }\n    return RiveService.instance;\n  }\n\n  public setRiveInstance(instance: any) {\n    this.riveInstance = instance;\n  }\n\n  public getRiveInstance() {\n    return this.riveInstance;\n  }\n}\n","import { convertUrlToRelative, highlightSpeakingElement, stopHighlightForSpeakingElement, speakText } from './utils';\n\nexport class AudioPlayer {\n  private static instance: AudioPlayer;\n  private audioElement: HTMLAudioElement;\n\n  private constructor() {\n    this.audioElement = document.createElement('audio');\n    this.audioElement.id = 'audio';\n    document.body.appendChild(this.audioElement);\n  }\n\n  public static getI(): AudioPlayer {\n    if (!AudioPlayer.instance) {\n      AudioPlayer.instance = new AudioPlayer();\n    }\n    return AudioPlayer.instance;\n  }\n\n  public stop() {\n    //check if speechSynthesis is supported\n    if (window?.speechSynthesis) {\n      window.speechSynthesis.cancel();\n    }\n    this.audioElement.pause();\n    this.audioElement.currentTime = 0;\n    this.audioElement.src = '';\n    const highlightedElements = document.querySelectorAll('.speaking-highlight');\n    highlightedElements.forEach(element => stopHighlightForSpeakingElement(element as HTMLElement));\n    \n    const playElement = document.querySelector(\"#play\") as HTMLElement;\n    const pauseElement = document.querySelector(\"#pause\") as HTMLElement;\n    if(playElement && pauseElement){\n      playElement.style.visibility = \"visible\";\n      pauseElement.style.visibility = \"hidden\";\n    }\n\n  }\n\n  public async play(targetElement: HTMLElement) {\n    let audioUrl = targetElement.getAttribute('audio') || '';\n\n    if (!audioUrl) {\n      const childElements = targetElement.children;\n      for (let i = 0; i < childElements.length; i++) {\n        const childAudioUrl = childElements[i].getAttribute('audio');\n        if (childAudioUrl) {\n          audioUrl = childAudioUrl;\n        }\n      }\n    }\n\n    if (audioUrl) {\n      audioUrl = convertUrlToRelative(audioUrl);\n      this.audioElement.src = audioUrl;\n      console.log('🚀 Playing audio:', this.audioElement.src);\n\n      try {\n        await this.audioElement.play();\n        highlightSpeakingElement(targetElement);\n\n        await new Promise<void>(resolve => {\n          this.audioElement.onended = () => {\n            stopHighlightForSpeakingElement(targetElement);\n            resolve();\n          };\n        });\n      } catch (error) {\n        console.log('🚀 Audio play error:', error);\n      }\n    }\n    // If no audio, use text-to-speech\n    else if (targetElement.textContent) {\n      try {\n        highlightSpeakingElement(targetElement);\n        await speakText(targetElement.textContent, targetElement);\n        stopHighlightForSpeakingElement(targetElement);\n      } catch (error) {\n        console.log('🚀 TTS Error:', error);\n      }\n    }\n  }\n}\n","import { ActivityScoreKey, DragSelectedMapKey, DropHasDrag, DropLength, LessonEndKey, SelectedValuesKey } from './constants';\nimport { dispatchActivityEndEvent, dispatchClickEvent, dispatchElementDropEvent, dispatchLessonEndEvent, dispatchNextContainerEvent } from './customEvents';\nimport GameScore from './constants';\nimport { RiveService } from './rive-service';\nimport { getAssetPath } from '@stencil/core';\nimport { AudioPlayer } from './audioPlayer';\nconst gameScore = new GameScore();\n\nexport function format(first?: string, middle?: string, last?: string): string {\n  return (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '');\n}\n\n// Function to get the scale of an element\nconst getElementScale = (el: HTMLElement): number => {\n  el.style.animation = 'unset';\n  const transform = window.getComputedStyle(el).transform;\n  if (transform === 'none') {\n    return 1; // No scaling\n  } else {\n    const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n    if (matrix) {\n      const matrixValues = matrix[1].split(', ');\n      const scaleX = parseFloat(matrixValues[0]);\n      return scaleX; // Assuming uniform scaling (same scale in X and Y)\n    }\n  }\n  return 1; // Fallback to no scaling\n};\n\nfunction slidingWithScaling(element: HTMLElement): void {\n  let overlapElement = false;\n  let isDragging = false;\n  let startX = 0;\n  let startY = 0;\n  let initialX = 0;\n  let initialY = 0;\n\n  // Fetch the container element\n  const parentElement = element.parentElement;\n  if (!parentElement) {\n    console.error(`Parent element not found.`);\n    return;\n  }\n\n  let verticalDistance;\n  let horizontalDistance;\n\n  const onStart = (event: MouseEvent | TouchEvent): void => {\n    removeHighlight(element);\n    isDragging = true;\n\n    if (event instanceof MouseEvent) {\n      startX = event.clientX;\n      startY = event.clientY;\n    } else {\n      startX = event.touches[0].clientX;\n      startY = event.touches[0].clientY;\n    }\n\n    // Apply dragging styles to the element\n    element.style.opacity = '0.8';\n    element.style.cursor = 'grabbing';\n\n    // Parse the current transform values at the start of each drag\n    const transform = window.getComputedStyle(element).transform;\n    if (transform !== 'none') {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        initialX = parseFloat(matrixValues[4]);\n        initialY = parseFloat(matrixValues[5]);\n      }\n    } else {\n      initialX = 0;\n      initialY = 0;\n    }\n\n    const rect1 = parentElement.getBoundingClientRect();\n    const rect2 = element.getBoundingClientRect();\n    verticalDistance = rect1.top - rect2.top;\n    horizontalDistance = rect1.left - rect2.left;\n\n    document.addEventListener('mousemove', onMove);\n    document.addEventListener('mouseup', onEnd);\n    document.addEventListener('touchmove', onMove);\n    document.addEventListener('touchend', onEnd);\n  };\n\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n        const rect1 = parentElement.getBoundingClientRect();\n        const rect2 = element.getBoundingClientRect();\n        verticalDistance = rect1.top - rect2.top;\n        horizontalDistance = rect1.left - rect2.left;\n      }\n    }\n  });\n\n  // Configure the observer to watch for attribute changes\n  const observerConfig = {\n    attributes: true, // Monitor attribute changes\n    attributeFilter: ['style'], // Only observe changes to the 'style' attribute\n  };\n\n  // Start observing the element\n  observer.observe(parentElement, observerConfig);\n\n  const onMove = (event: MouseEvent | TouchEvent): void => {\n    if (!isDragging) return;\n    const parentElementScale = getElementScale(parentElement);\n    let dx = 0;\n    let dy = 0;\n\n    if (event instanceof MouseEvent) {\n      dx = (event.clientX - startX) / parentElementScale;\n      dy = (event.clientY - startY) / parentElementScale;\n    } else {\n      dx = (event.touches[0].clientX - startX) / parentElementScale;\n      dy = (event.touches[0].clientY - startY) / parentElementScale;\n    }\n\n    // Calculate the new position considering scaling\n    const newLeft = initialX + dx;\n    const newTop = initialY + dy;\n\n    // Get the dimensions and scale-corrected position of the container and element\n    const containerRect = parentElement.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n\n    const numbers = element.style.transform.match(/-?\\d+(\\.\\d+)?/g);\n    const result = numbers.map(Number);\n    const initialElementLeftPx = elementRect.left / parentElementScale - result[0];\n    const initialElementTopPx = elementRect.top - result[1];\n    const initialElementRightPx = elementRect.right / parentElementScale - result[0];\n    const initialElementBottomPx = elementRect.bottom - result[1];\n\n    const maxRight = containerRect.right - initialElementRightPx;\n    const maxLeft = containerRect.left - initialElementLeftPx;\n    const maxTop = containerRect.top - initialElementTopPx;\n    const maxBottom = containerRect.bottom - initialElementBottomPx;\n\n    const newLeftClamp = newLeft + initialElementLeftPx <= containerRect.left ? maxLeft : Math.min(newLeft, maxRight);\n    const newTopClamp = newTop + initialElementTopPx <= containerRect.top ? maxTop : Math.min(newTop, maxBottom);\n\n    // Apply transform with translation within boundaries\n    element.style.transform = `translate(${newLeftClamp}px, ${newTopClamp}px)`;\n\n    // Check for overlaps and highlight only the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(element, 'slide');\n\n    // Apply styles only to the most overlapped element\n    if (mostOverlappedElement) {\n      if (mostOverlappedElement != element) {\n        const parent1 = element.parentElement;\n        const parent2 = mostOverlappedElement.parentElement;\n\n        if (parent1 && parent2) {\n          // Temporarily detach both elements\n          const elementPlaceholder = document.createComment('element-placeholder');\n          const overlappedPlaceholder = document.createComment('overlapped-placeholder');\n          parent1.replaceChild(elementPlaceholder, element);\n          parent2.replaceChild(overlappedPlaceholder, mostOverlappedElement);\n          // Swap the elements\n          parent1.replaceChild(mostOverlappedElement, elementPlaceholder);\n          parent2.replaceChild(element, overlappedPlaceholder);\n          element.style.transform = 'translate(0, 0)';\n\n          // Recalculate starting points for the swapped element\n          startX = event instanceof MouseEvent ? event.clientX : event.touches[0].clientX;\n          startY = event instanceof MouseEvent ? event.clientY : event.touches[0].clientY;\n          initialX = 0;\n          initialY = 0;\n          overlapElement = true;\n        }\n      }\n    }\n  };\n\n  const onEnd = (endEv): void => {\n    isDragging = false;\n    document.removeEventListener('mousemove', onMove);\n    document.removeEventListener('mouseup', onEnd);\n    document.removeEventListener('touchmove', onMove);\n    document.removeEventListener('touchend', onEnd);\n\n    // Reset styles when dragging ends\n    element.style.opacity = '';\n    element.style.cursor = 'move';\n    element.style.transform = 'translate(0, 0)';\n\n    if (overlapElement) {\n      slideCompleted(element);\n      overlapElement = false;\n    }\n  };\n  // Initialize draggable element styles\n  element.style.cursor = 'move';\n  element.style.transform = 'translate(0, 0)'; // Initialize transform for consistent dragging\n\n  element.addEventListener('mousedown', onStart);\n  element.addEventListener('touchstart', onStart);\n  element.addEventListener('click', ev => {\n    onClickDropOrDragElement(element, 'drag');\n  });\n}\n\nconst slideCompleted = (slideElement: HTMLElement) => {\n  const slideArr = JSON.parse(localStorage.getItem(SelectedValuesKey)) || [];\n  const allSlideElements = document.querySelectorAll(\"[type='slide']\");\n\n  let index = 0;\n  allSlideElements.forEach(item => {\n    slideArr[index++] = item['value'];\n  });\n  localStorage.setItem(SelectedValuesKey, JSON.stringify(slideArr));\n\n  const objectiveString = document.querySelector('#lido-container')['objective'];\n  const objectiveArray = objectiveString.split(',');\n  const elementIndex = slideArr.indexOf(slideElement['value']);\n  const isCorrect = matchStringPattern(slideElement['value'], [objectiveArray[elementIndex].trim()]);\n  storingEachActivityScore(isCorrect);\n  handleShowCheck();\n};\n\nfunction enableDraggingWithScaling(element: HTMLElement): void {\n  let isDragging = false;\n  let isClicked = true;\n  let startX = 0;\n  let startY = 0;\n  let initialX = 0;\n  let initialY = 0;\n\n  // Fetch the container element\n  const container = document.querySelector('#lido-container') as HTMLElement;\n  if (!container) {\n    console.error(`Container with ID \"container\" not found.`);\n    return;\n  }\n\n  handlingElementFlexibleWidth(element, 'drag');\n\n  let verticalDistance;\n  let horizontalDistance;\n\n  const onStart = (event: MouseEvent | TouchEvent): void => {\n    AudioPlayer.getI().stop();\n    removeHighlight(element);\n    isDragging = true;\n\n    if (event instanceof MouseEvent) {\n      startX = event.clientX;\n      startY = event.clientY;\n    } else {\n      startX = event.touches[0].clientX;\n      startY = event.touches[0].clientY;\n    }\n\n    // Apply dragging styles to the element\n    element.style.opacity = '0.8';\n    element.style.cursor = 'grabbing';\n\n    // Parse the current transform values at the start of each drag\n    const transform = window.getComputedStyle(element).transform;\n    if (transform !== 'none') {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n\n        initialX = parseFloat(matrixValues[4]);\n        initialY = parseFloat(matrixValues[5]);\n      }\n    } else {\n      initialX = 0;\n      initialY = 0;\n    }\n\n    document.addEventListener('mousemove', onMove);\n    document.addEventListener('mouseup', onEnd);\n    document.addEventListener('touchmove', onMove);\n    document.addEventListener('touchend', onEnd);\n  };\n\n  const rect1 = container.getBoundingClientRect();\n  const rect2 = element.getBoundingClientRect();\n  verticalDistance = rect1.top - rect2.top;\n  horizontalDistance = rect1.left - rect2.left;\n\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n        const rect1 = container.getBoundingClientRect();\n        const rect2 = element.getBoundingClientRect();\n        verticalDistance = rect1.top - rect2.top;\n        horizontalDistance = rect1.left - rect2.left;\n      }\n    }\n  });\n\n  // Configure the observer to watch for attribute changes\n  const observerConfig = {\n    attributes: true, // Monitor attribute changes\n    attributeFilter: ['style'], // Only observe changes to the 'style' attribute\n  };\n\n  // Start observing the element\n  observer.observe(container, observerConfig);\n\n  const onMove = (event: MouseEvent | TouchEvent): void => {\n    if (!isDragging) return;\n    isClicked = false;\n    element.style.transition = 'none';\n    const containerScale = getElementScale(container);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (event instanceof MouseEvent) {\n      dx = (event.clientX - startX) / containerScale;\n      dy = (event.clientY - startY) / containerScale;\n    } else {\n      dx = (event.touches[0].clientX - startX) / containerScale;\n      dy = (event.touches[0].clientY - startY) / containerScale;\n    }\n\n    // Calculate the new position considering scaling\n    const newLeft = initialX + dx;\n    const newTop = initialY + dy;\n\n    // Get the dimensions and scale-corrected position of the container and element\n    const containerRect = container.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n\n    const numbers = element.style.transform.match(/-?\\d+(\\.\\d+)?/g);\n    const result = numbers.map(Number);\n    const initialElementLeftPx = elementRect.left / containerScale - result[0];\n    const initialElementTopPx = elementRect.top - result[1];\n\n    const maxRight = containerRect.width / containerScale - Math.abs(horizontalDistance / containerScale) - elementRect.width / containerScale;\n    const maxLeft = containerRect.left - initialElementLeftPx;\n    const maxTop = containerRect.top - initialElementTopPx;\n    const maxBottom = containerRect.height / containerScale - Math.abs(verticalDistance / containerScale) - elementRect.height / containerScale;\n\n    const newLeftClamp = newLeft + initialElementLeftPx <= containerRect.left ? maxLeft : Math.min(newLeft, maxRight);\n    const newTopClamp = newTop + initialElementTopPx <= containerRect.top ? maxTop : Math.min(newTop, maxBottom);\n\n    // Apply transform with translation within boundaries\n    element.style.transform = `translate(${newLeftClamp}px, ${newTopClamp}px)`;\n\n    // Check for overlaps and highlight only the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(element, 'drop');\n\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n    // Reset styles for all elements\n    allElements.forEach(otherElement => {\n      const dropObject = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n      const storedTabIndexes = Object.keys(dropObject).map(Number);\n      if (storedTabIndexes.includes(otherElement['tabIndex'])) {\n        if (otherElement.tagName.toLowerCase() === 'lido-text') {\n          otherElement.style.border = ''; // Reset border\n          otherElement.style.backgroundColor = 'transparent'; // Reset background color\n        }\n        if (otherElement.tagName.toLowerCase() === 'lido-image') {\n          otherElement.style.visibility = 'hidden';\n        }\n      } else {\n        if (otherElement.tagName.toLowerCase() === 'lido-text') {\n          otherElement.style.border = ''; // Reset border\n          otherElement.style.backgroundColor = ''; // Reset background color\n        }\n        if (otherElement.tagName.toLowerCase() === 'lido-image') {\n          otherElement.style.visibility = 'visible';\n          otherElement.style.opacity = '1';\n        }\n      }\n    });\n    // Apply styles only to the most overlapped element\n    if (mostOverlappedElement) {\n      if (mostOverlappedElement.tagName.toLowerCase() === 'lido-text') {\n        mostOverlappedElement.style.border = '2px dashed #ff0000'; // Red dashed border\n        mostOverlappedElement.style.backgroundColor = 'rgba(255, 0, 0, 0.1)'; // Light red background\n      } else {\n        mostOverlappedElement.style.opacity = '0.3';\n      }\n    }\n  };\n\n  const onEnd = (endEv): void => {\n    isDragging = false;\n    if (isClicked) return;\n    isClicked = true;\n    document.removeEventListener('mousemove', onMove);\n    document.removeEventListener('mouseup', onEnd);\n    document.removeEventListener('touchmove', onMove);\n    document.removeEventListener('touchend', onEnd);\n\n    // Reset styles when dragging ends\n    element.style.opacity = '';\n    element.style.cursor = 'move';\n\n    // Reset overlapping styles from all elements\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n    allElements.forEach(otherElement => {\n      allElements.forEach(otherElement => {\n        const dropObject = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n        const storedTabIndexes = Object.keys(dropObject).map(Number);\n        if (storedTabIndexes.includes(otherElement['tabIndex'])) {\n          if (otherElement.tagName.toLowerCase() === 'lido-text') {\n            otherElement.style.border = ''; // Reset border\n            otherElement.style.backgroundColor = 'transparent'; // Reset background color\n          }\n          if (otherElement.tagName.toLowerCase() === 'lido-image') {\n            otherElement.style.opacity = '0';\n          }\n        } else {\n          if (otherElement.tagName.toLowerCase() === 'lido-text') {\n            otherElement.style.border = ''; // Reset border\n            otherElement.style.backgroundColor = ''; // Reset background color\n          }\n          if (otherElement.tagName.toLowerCase() === 'lido-image') {\n            otherElement.style.opacity = '1';\n          }\n        }\n      });\n    });\n\n    // Check for overlaps and log the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(element, 'drop');\n    onElementDropComplete(element, mostOverlappedElement);\n  };\n  // Initialize draggable element styles\n  element.style.cursor = 'move';\n  element.style.transform = 'translate(0, 0)'; // Initialize transform for consistent dragging\n  element.addEventListener('mousedown', onStart);\n  element.addEventListener('touchstart', onStart);\n  element.addEventListener('click', ev => {\n    onClickDropOrDragElement(element, 'drag');\n  });\n}\n\nconst findMostoverlappedElement = (element: HTMLElement, type: string) => {\n  const elementRect = element.getBoundingClientRect();\n  const allElements = document.querySelectorAll<HTMLElement>(`[type=\"${type}\"]`);\n\n  let mostOverlappedElement: HTMLElement | null = null;\n  let maxOverlapArea = 0;\n\n  allElements.forEach(otherElement => {\n    if (otherElement === element) return;\n    const otherRect = otherElement.getBoundingClientRect();\n\n    const overlapWidth = Math.max(0, Math.min(elementRect.right, otherRect.right) - Math.max(elementRect.left, otherRect.left));\n    const overlapHeight = Math.max(0, Math.min(elementRect.bottom, otherRect.bottom) - Math.max(elementRect.top, otherRect.top));\n    const overlapArea = overlapWidth * overlapHeight;\n\n    if (overlapArea === 0) return; \n\n    if (type === 'slide') {\n      const elementArea = elementRect.width * elementRect.height;\n      const otherArea = otherRect.width * otherRect.height;\n      const minRequiredOverlap = Math.min(elementArea, otherArea) * 0.8;\n\n      if (overlapArea >= minRequiredOverlap && overlapArea > maxOverlapArea) {\n        maxOverlapArea = overlapArea;\n        mostOverlappedElement = otherElement;\n      }\n    } else if (overlapArea > maxOverlapArea) {\n      maxOverlapArea = overlapArea;\n      mostOverlappedElement = otherElement;\n    }\n  });\n\n  return mostOverlappedElement;\n};\n\nasync function onElementDropComplete(dragElement: HTMLElement, dropElement: HTMLElement): Promise<void> {\n  const selectedValueData = localStorage.getItem(SelectedValuesKey) || '';\n  const dragSelectedData = localStorage.getItem(DragSelectedMapKey);\n  let dropHasDrag = JSON.parse(localStorage.getItem(DropHasDrag) || ' {}') as Record<string, { drop: string; isFull: boolean }>;\n  if (dropElement) {\n\n    if (dropElement.getAttribute('isAllowOnlyOneDrop') === 'true' || !dropElement.getAttribute('isAllowOnlyOneDrop')) {\n      const isisFull = Object.values(dropHasDrag).find(item => document.getElementById(item.drop) === dropElement);\n      isisFull.isFull = true;\n      localStorage.setItem(DropHasDrag, JSON.stringify(dropHasDrag));\n      // Check for overlaps and highlight only the most overlapping element\n      let mostOverlappedElement: HTMLElement = findMostoverlappedElement(dragElement, 'drag');\n      if (mostOverlappedElement) {\n        dragElement.style.transform = 'translate(0,0)';\n        if (dragSelectedData) {\n          let dragSelected = JSON.parse(dragSelectedData);\n          for (const key in dragSelected) {\n            if (dragSelected[key].includes(dragElement['value'])) {\n              delete dragSelected[key];\n            }\n          }\n          localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragSelected));\n        }\n        const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n        allElements.forEach(otherElement => {\n          const dropObject = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n          const storedTabIndexes = Object.keys(dropObject).map(Number);\n          if (storedTabIndexes.includes(otherElement['tabIndex'])) {\n            if (otherElement.tagName.toLowerCase() === 'lido-text') {\n              otherElement.style.border = ''; // Reset border\n              otherElement.style.backgroundColor = 'transparent'; // Reset background color\n            }\n            if (otherElement.tagName.toLowerCase() === 'lido-image') {\n              otherElement.style.opacity = '0';\n            }\n          } else {\n            if (otherElement.tagName.toLowerCase() === 'lido-text') {\n              otherElement.style.border = ''; // Reset border\n              otherElement.style.backgroundColor = ''; // Reset background color\n            }\n            if (otherElement.tagName.toLowerCase() === 'lido-image') {\n              otherElement.style.opacity = '1';\n            }\n          }\n        });\n        return;\n      }\n    }\n  }\n  if (!dropElement) {\n    let currentDrop = dragToDropMap.get(dragElement);\n    if (currentDrop) {\n      let prevDropItem = Object.values(dropHasDrag).find(item => document.getElementById(item.drop) === currentDrop);\n      if (prevDropItem) {\n        prevDropItem.isFull = false;\n        localStorage.setItem(DropHasDrag, JSON.stringify(dropHasDrag));\n      }\n    }\n\n    if (selectedValueData) {\n      let selectedValue = JSON.parse(selectedValueData);\n      selectedValue = selectedValue.filter(value => value != dragElement['value']);\n      localStorage.setItem(SelectedValuesKey, JSON.stringify(selectedValue));\n    }\n    if (dragSelectedData) {\n      let dragSelected = JSON.parse(dragSelectedData);\n      for (const key in dragSelected) {\n        if (dragSelected[key].includes(dragElement['value'])) {\n          delete dragSelected[key];\n        }\n      }\n      localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragSelected));\n    }\n\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n    allElements.forEach(otherElement => {\n      const dropObject = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n      const storedTabIndexes = Object.keys(dropObject).map(Number);\n      if (storedTabIndexes.includes(otherElement['tabIndex'])) {\n        if (otherElement.tagName.toLowerCase() === 'lido-text') {\n          otherElement.style.border = ''; // Reset border\n          otherElement.style.backgroundColor = 'transparent'; // Reset background color\n        }\n        if (otherElement.tagName.toLowerCase() === 'lido-image') {\n          otherElement.style.opacity = '0';\n        }\n      } else {\n        if (otherElement.tagName.toLowerCase() === 'lido-text') {\n          otherElement.style.border = ''; // Reset border\n          otherElement.style.backgroundColor = ''; // Reset background color\n        }\n        if (otherElement.tagName.toLowerCase() === 'lido-image') {\n          otherElement.style.opacity = '1';\n        }\n      }\n    });\n\n    handleShowCheck();\n    return;\n  }\n\n  if (dragSelectedData) {\n    let currentDrop = dragToDropMap.get(dragElement);\n    if (currentDrop) {\n      let prevDropItem = Object.values(dropHasDrag).find(item => document.getElementById(item.drop) === currentDrop);\n      if (prevDropItem) {\n        prevDropItem.isFull = false;\n        localStorage.setItem(DropHasDrag, JSON.stringify(dropHasDrag));\n      }\n    }\n    let dragSelected = JSON.parse(dragSelectedData);\n    for (const key in dragSelected) {\n      if (dragSelected[key].includes(dragElement['value'])) {\n        delete dragSelected[key];\n      }\n    }\n    localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragSelected));\n  }\n  let dropLength = JSON.parse(localStorage.getItem(DropLength)) || 0;\n  dropLength += 1;\n  localStorage.setItem(DropLength, JSON.stringify(dropLength));\n\n  if (dropLength === countPatternWords(dropElement['value'])) {\n    const isisFull = Object.values(dropHasDrag).find(item => document.getElementById(item.drop) === dropElement);\n    isisFull.isFull = true;\n    localStorage.setItem(DropHasDrag, JSON.stringify(dropHasDrag));\n    dropLength = 0;\n    localStorage.setItem(DropLength, JSON.stringify(dropLength));\n  }\n\n  dragToDropMap.set(dragElement, dropElement);\n\n  // Add pulse and highlight effect for a successful match\n  const isCorrect = dropElement['value'].includes(dragElement['value']);\n  dispatchElementDropEvent(dragElement, dropElement, isCorrect);\n  if (isCorrect) {\n    // Perform actions if onMatch is defined\n    const onCorrect = dropElement.getAttribute('onCorrect');\n    if (onCorrect) {\n      await executeActions(onCorrect, dropElement, dragElement);\n    }\n  } else {\n    const onInCorrect = dropElement.getAttribute('onInCorrect');\n\n    await executeActions(onInCorrect, dropElement, dragElement);\n\n    // showWrongAnswerAnimation([dropElement, dragElement]);\n  }\n  storingEachActivityScore(isCorrect);\n  await onActivityComplete(dragElement, dropElement);\n}\n\n// Function to execute actions parsed from the onMatch string\nconst executeActions = async (actionsString: string, thisElement: HTMLElement, element?: HTMLElement): Promise<void> => {\n  const actions = parseActions(actionsString);\n\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i];\n\n    const queriedElement = document.querySelector(action.actor) as HTMLElement | null;\n    const targetElement = action.actor === 'this' ? thisElement : action.actor === 'element' ? element : queriedElement ? queriedElement : document.getElementById(action.actor);\n\n    if (targetElement) {\n      // Handle the 'transform' property separately\n      switch (action.action) {\n        case 'transform': {\n          const currentTransform = window.getComputedStyle(targetElement).transform;\n          targetElement.style.transform = currentTransform !== 'none' ? `${currentTransform} ${action.value}` : action.value;\n          break;\n        }\n        case 'alignMatch': {\n          const dropElement = targetElement;\n          const dragElement = element;\n\n          const container = document.querySelector('#lido-container') as HTMLElement;\n          const containerScale = getElementScale(container);\n          dragElement.style.transform = 'translate(0,0)';\n\n          const dropRect = dropElement.getBoundingClientRect();\n          const dragRect = dragElement.getBoundingClientRect();\n\n          const dropCenterX = dropRect.left + dropRect.width / 2;\n          const dropCenterY = dropRect.top + dropRect.height / 2;\n          const dragCenterX = dragRect.left + dragRect.width / 2;\n          const dragCenterY = dragRect.top + dragRect.height / 2;\n\n          const scaledLeft = (dropCenterX - dragCenterX) / containerScale;\n          const scaledTop = (dropCenterY - dragCenterY) / containerScale;\n\n          dragElement.style.transform = `translate(${scaledLeft}px, ${scaledTop}px)`;\n          break;\n        }\n        case 'addClass': {\n          targetElement.classList.add(action.value);\n          break;\n        }\n        case 'speak': {\n          await AudioPlayer.getI().play(targetElement);\n          break;\n        }\n        case 'stop': {\n          await AudioPlayer.getI().stop();\n          break;\n        }\n\n        case 'sleep': {\n          const isNumber = !isNaN(Number(action.value));\n          if (isNumber) {\n            await new Promise(resolve => setTimeout(resolve, Number(action.value)));\n          }\n          break;\n        }\n\n        case 'avatarAnimate': {\n          const riveService = RiveService.getInstance();\n          const riveInstance = riveService.getRiveInstance();\n\n          if (riveInstance && action.value) {\n            riveInstance.play(action.value);\n          }\n          break;\n        }\n\n        default: {\n          targetElement.style[action.action] = action.value;\n          break;\n        }\n      }\n    }\n  }\n};\n\n// Function to parse actions string\nconst parseActions = (input: string): Array<{ actor: string; action: string; value: string }> => {\n  const actions = [];\n  if (!input) return actions;\n  const actionStrings = input.split(';')?.map(action => action.trim());\n\n  actionStrings.forEach(actionString => {\n    if (actionString) {\n      const [actorAction, value] = actionString.split('=').map(part => part.trim());\n      const lastDotIndex = actorAction.lastIndexOf('.');\n      if (lastDotIndex !== -1) {\n        const actor = actorAction.substring(0, lastDotIndex).trim();\n        const action = actorAction.substring(lastDotIndex + 1).trim();\n        actions.push({ actor, action, value: value.replace(/['\"]/g, '') });\n      }\n    }\n  });\n\n  return actions;\n};\n\nconst matchStringPattern = (pattern: string, arr: string[]): boolean => {\n  const patternGroups = pattern.split(',').map(group => group.trim());\n\n  let arrIndex = 0;\n  let options = new Set<string>();\n\n  for (const group of patternGroups) {\n    if (group.startsWith('(') && group.endsWith(')')) {\n      // Inside parentheses: '|' acts like \"OR\" condition\n      const choices = group\n        .slice(1, -1)\n        .split('|')\n        .map(option => option.trim());\n\n      const arrChoice = arr[arrIndex]\n        .slice(1, -1)\n        .split('|')\n        .map(option => option.trim());\n\n      if (arrIndex >= arrChoice.length) return false;\n      for (let i = 0; i < choices.length; i++) {\n        if (!choices.includes(arrChoice[i])) return false;\n      }\n      arrIndex++;\n    } else if (group.includes('|')) {\n      // Outside parentheses: '|' acts as optional order\n      const choices = group.split('|').map(option => option.trim());\n\n      for (const choice of choices) {\n        options.add(choice);\n      }\n    } else {\n      // Exact match required\n      if (arrIndex >= arr.length || arr[arrIndex] !== group) return false;\n\n      arrIndex++;\n    }\n  }\n\n  // Validate the optional ordered items against the remaining array elements\n  while (arrIndex < arr.length) {\n    if (!options.has(arr[arrIndex])) {\n      return false;\n    }\n    options.delete(arr[arrIndex]);\n    arrIndex++;\n  }\n\n  return arrIndex === arr.length;\n};\n\nconst countPatternWords = (pattern: string): number => {\n  const patternGroups = pattern.split(',').map(group => group.trim());\n\n  let wordCount = 0;\n\n  for (const group of patternGroups) {\n    if (group.startsWith('(') && group.endsWith(')')) {\n      if (group.includes('|')) {\n        wordCount += group.split('|').length;\n      } else {\n        wordCount += 1;\n      }\n    } else {\n      wordCount += group.split('|').length;\n    }\n  }\n\n  return wordCount;\n};\n\nasync function onActivityComplete(dragElement?: HTMLElement, dropElement?: HTMLElement) {\n  const container = document.querySelector('#lido-container') as HTMLElement;\n  if (!container) return;\n\n  const isAllowOnlyCorrect = container.getAttribute('isAllowOnlyCorrect') === 'true';\n  if (isAllowOnlyCorrect) {\n    const isCorrect = dropElement['value'].includes(dragElement['value']);\n    if (!isCorrect) {\n      dragElement.style.transform = 'translate(0,0)';\n      return;\n    }\n  }\n\n  await executeActions(\"this.alignMatch='true'\", dropElement, dragElement);\n\n  let dragScore = JSON.parse(localStorage.getItem(DragSelectedMapKey) ?? '{}');\n  const tabindex = dropElement.getAttribute('tabindex');\n\n  if (!dragScore[tabindex]) {\n    dragScore[tabindex] = [];\n  }\n\n  dragScore[tabindex].push(dragElement['value']);\n\n  localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragScore));\n\n  const sortedKeys = Object.keys(dragScore).sort((a, b) => parseInt(a) - parseInt(b));\n\n  const sortedValues = sortedKeys.reduce((acc, key) => {\n    const values = dragScore[key];\n    if (values.length > 1) {\n      acc.push(`(${values.join('|')})`);\n    } else {\n      acc.push(values[0]);\n    }\n    return acc;\n  }, []);\n\n  localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n\n  const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n  allElements.forEach(otherElement => {\n    const dropObject = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n    const storedTabIndexes = Object.keys(dropObject).map(Number);\n    if (storedTabIndexes.includes(otherElement['tabIndex'])) {\n      if (otherElement.tagName.toLowerCase() === 'lido-text') {\n        otherElement.style.border = ''; // Reset border\n        otherElement.style.backgroundColor = 'transparent'; // Reset background color\n      }\n      if (otherElement.tagName.toLowerCase() === 'lido-image') {\n        otherElement.style.opacity = '0';\n      }\n    } else {\n      if (otherElement.tagName.toLowerCase() === 'lido-text') {\n        otherElement.style.border = ''; // Reset border\n        otherElement.style.backgroundColor = ''; // Reset background color\n      }\n      if (otherElement.tagName.toLowerCase() === 'lido-image') {\n        otherElement.style.opacity = '1';\n      }\n    }\n  });\n  handleShowCheck();\n}\n\nconst storingEachActivityScore = (flag: boolean) => {\n  if (flag) {\n    gameScore.rightMoves += 1;\n  } else {\n    gameScore.wrongMoves += 1;\n  }\n  console.log('Right Moves : ', gameScore.rightMoves);\n  console.log('Wrong Moves : ', gameScore.wrongMoves);\n};\n\nconst calculateScore = () => {\n  const rightMoves = gameScore.rightMoves;\n  const wrongMoves = gameScore.wrongMoves;\n  let finalScore = Math.floor((rightMoves / (rightMoves + wrongMoves)) * 100);\n  storeActivityScore(finalScore);\n  gameScore.rightMoves = 0;\n  gameScore.wrongMoves = 0;\n};\n\nconst storeActivityScore = (score: number) => {\n  const appHome = document.querySelector('lido-home');\n  if (!appHome) return;\n  const index = Number(appHome.getAttribute('index') ?? 0);\n  const totalIndex = Number(appHome.getAttribute('totalIndex') ?? 0);\n\n  const activityScore = JSON.parse(localStorage.getItem(ActivityScoreKey) ?? '{}');\n  const activityScoreKey = index.toString();\n  activityScore[activityScoreKey] = score;\n\n  //send Custom Event to parent\n  // window.dispatchEvent(new CustomEvent(ActivityEndKey, { detail: { index: index, totalIndex: totalIndex, score: score } }));\n  dispatchActivityEndEvent(index, totalIndex, score);\n\n  localStorage.setItem(ActivityScoreKey, JSON.stringify(activityScore));\n  if (totalIndex - 1 == index) {\n    const scoresArray: number[] = Object.values(activityScore);\n    const finalScore = scoresArray.reduce((acc, cur) => acc + cur, 0) / scoresArray.length;\n    gameScore.finalScore = Math.floor(finalScore);\n    console.log('Total Score : ', gameScore.finalScore);\n    // window.dispatchEvent(new CustomEvent(LessonEndKey, { detail: { score: finalScore } }));\n    dispatchLessonEndEvent(finalScore);\n    localStorage.removeItem(ActivityScoreKey);\n  }\n};\n\nconst handleShowCheck = () => {\n  const container = document.querySelector('#lido-container') as HTMLElement;\n  const objectiveString = container['objective'];\n  const selectValues = localStorage.getItem(SelectedValuesKey) ?? '';\n\n  const checkButton = document.querySelector('#lido-checkButton') as HTMLElement;\n\n  if (!selectValues || countPatternWords(selectValues) !== countPatternWords(objectiveString)) {\n    executeActions(\"this.addClass='lido-disable-check-button'\", checkButton);\n    return;\n  }\n\n  const showCheck = container.getAttribute('showCheck') == 'true';\n\n  if (showCheck) {\n    checkButton.classList.remove('lido-disable-check-button');\n  } else {\n    validateObjectiveStatus();\n  }\n};\n\nconst validateObjectiveStatus = async () => {\n  const container = document.querySelector('#lido-container') as HTMLElement;\n  if (!container) return;\n  const objectiveString = container['objective'];\n  const objectiveArray = JSON.parse(localStorage.getItem(SelectedValuesKey)) ?? [];\n  const res = matchStringPattern(objectiveString, objectiveArray);\n\n  if (res) {\n    appendingDragElementsInDrop();\n    const onCorrect = container.getAttribute('onCorrect');\n    if (onCorrect) {\n      await executeActions(onCorrect, container);\n    }\n    triggerNextContainer();\n  } else {\n    const onInCorrect = container.getAttribute('onInCorrect');\n    await executeActions(onInCorrect, container);\n    const isContinueOnCorrect = container.getAttribute('isContinueOnCorrect') === 'true';\n    if (!isContinueOnCorrect) {\n      triggerNextContainer();\n    }\n  }\n  await calculateScore();\n};\n\nconst appendingDragElementsInDrop = () => {\n  const dragItems = document.querySelectorAll(\"[type='drag']\");\n  const dropItems = document.querySelectorAll(\"[type='drop']\");\n  if (!dragItems || !dropItems) return;\n  dropItems.forEach(drop => {\n    const dropElement = drop as HTMLElement;\n    dropElement.style.opacity = \"1\"\n    dragItems.forEach(dragElement => {\n      const drag = dragElement as HTMLElement;\n      if (drop['value'].includes(drag['value'])) {\n        drag.style.transform = 'translate(0,0)';\n        drop.appendChild(drag);\n      }\n    });\n  });\n};\n\nexport const triggerNextContainer = () => {\n  AudioPlayer.getI().stop();\n  // const event = new CustomEvent('nextContainer');\n  console.log('🚀 ~ triggerNextContainer ~ event:', event);\n  // window.dispatchEvent(event);\n  dispatchNextContainerEvent();\n};\n\nexport const initEventsForElement = async (element: HTMLElement, type: string) => {\n  const container = document.querySelector('#lido-container') as HTMLElement;\n  if (!container) return;\n  const onEntry = element.getAttribute('onEntry');\n  await executeActions(onEntry, element);\n  const canplay = container.getAttribute('canplay');\n  if (canplay != null && canplay === 'false') return;\n  switch (type) {\n    case 'drag': {\n      enableDraggingWithScaling(element);\n      break;\n    }\n    case 'click': {\n      addClickListenerForClickType(element);\n      break;\n    }\n    case 'drop': {\n      handleDropElement(element);\n      break;\n    }\n    case 'slide': {\n      slidingWithScaling(element);\n      break;\n    }\n    default:\n      break;\n  }\n\n  onTouchListenerForOnTouch(element);\n};\n\nfunction onTouchListenerForOnTouch(element: HTMLElement) {\n  if (!element) return;\n  const onTouch = element.getAttribute('onTouch');\n  if (!onTouch) return;\n  element.onclick = async () => {\n    console.log('🚀 ~ element.onclick= ~ onTouch:', onTouch);\n    if (!onTouch) return;\n    await executeActions(onTouch, element);\n  };\n}\n\nfunction addClickListenerForClickType(element: HTMLElement): void {\n  handlingElementFlexibleWidth(element, 'click');\n  element.style.cursor = 'pointer';\n  if (!element) {\n    console.error('No element provided.');\n    return;\n  }\n\n  const onClick = async () => {\n    AudioPlayer.getI().stop();\n    const container = document.querySelector('#lido-container') as HTMLElement;\n    const objective = container['objective'].split(',');\n    const checkButton = document.querySelector('#lido-checkButton') as HTMLElement;\n    const showCheck = container.getAttribute('showCheck') === 'true';\n\n    if (element.getAttribute('id') == 'lido-checkButton') {\n      checkButton.classList.add('lido-disable-check-button');\n      await validateObjectiveStatus();\n      return;\n    }\n\n    // element.style.border = '2px solid yellow';\n    // element.style.boxShadow = '0px 0px 10px rgba(255, 255, 0, 0.7)';\n\n    // element.style.transition = 'transform 0.2s ease, border 0.5s ease';\n    // element.style.transform = 'scale(1.1)';\n\n    // element.style.transform = 'scale(1)';\n    // element.style.border = '';\n    // element.style.boxShadow = '';\n\n    const isActivated = element.classList.contains('lido-element-selected');\n    let selectedValue = JSON.parse(localStorage.getItem(SelectedValuesKey)) || [];\n\n    if (objective.length === 1) {\n      localStorage.setItem(SelectedValuesKey, JSON.stringify([element['value']]));\n      const isCorrect = objective.includes(element['value']);\n      dispatchClickEvent(element, isCorrect);\n      if (isCorrect) {\n        const onCorrect = element.getAttribute('onCorrect');\n        element.style.pointerEvents = \"none\";\n        await executeActions(onCorrect, element);\n      } else {\n        const onInCorrect = element.getAttribute('onInCorrect');\n        await executeActions(onInCorrect, element);\n        // showWrongAnswerAnimation([element]);\n      }\n      storingEachActivityScore(isCorrect);\n      handleShowCheck();\n      return;\n    }\n\n    if (showCheck) {\n      checkButton.classList.remove('lido-disable-check-button');\n    }\n\n    if (isActivated) {\n      element.classList.remove('lido-element-selected');\n      executeActions(element.getAttribute('onEntry'), element);\n\n      selectedValue = selectedValue.filter(item => item != element['value']);\n      localStorage.setItem(SelectedValuesKey, JSON.stringify(selectedValue));\n\n      let multiOptionScore = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n      const valueToRemove = element['value'];\n      const keyToRemove = Object.keys(multiOptionScore).find(key => multiOptionScore[key].includes(valueToRemove));\n\n      if (keyToRemove) {\n        multiOptionScore[keyToRemove] = multiOptionScore[keyToRemove].filter(item => item !== valueToRemove);\n        if (multiOptionScore[keyToRemove].length === 0) {\n          delete multiOptionScore[keyToRemove];\n        }\n        localStorage.setItem(DragSelectedMapKey, JSON.stringify(multiOptionScore));\n        const sortedKeys = Object.keys(multiOptionScore).sort((a, b) => parseInt(a) - parseInt(b));\n        const sortedValues = sortedKeys.reduce((acc, key) => acc.concat(multiOptionScore[key]), []);\n        localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n      }\n\n      if (showCheck && selectedValue.length === 0) {\n        checkButton.classList.add('lido-disable-check-button');\n      }\n      return;\n    } else {\n      element.classList.add('lido-element-selected');\n      const valueToFind = element['value'];\n      const key = Object.keys(objective).find(key => objective[key] === valueToFind);\n      let multiOptionScore = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n      if (!key) {\n        multiOptionScore[objective.length + selectedValue.length] = [valueToFind];\n      } else {\n        multiOptionScore[key] = [valueToFind];\n      }\n      localStorage.setItem(DragSelectedMapKey, JSON.stringify(multiOptionScore));\n      const sortedKeys = Object.keys(multiOptionScore).sort((a, b) => parseInt(a) - parseInt(b));\n      const sortedValues = sortedKeys.reduce((acc, key) => acc.concat(multiOptionScore[key]), []);\n      localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n\n      const isCorrect = objective.includes(element['value']);\n      dispatchClickEvent(element, isCorrect);\n      if (isCorrect) {\n        const onCorrect = element.getAttribute('onCorrect');\n        await executeActions(onCorrect, element);\n      } else {\n        const onInCorrect = element.getAttribute('onInCorrect');\n        await executeActions(onInCorrect, element);\n        // showWrongAnswerAnimation([element]);\n      }\n      storingEachActivityScore(isCorrect);\n    }\n\n    if (!showCheck && countPatternWords(objective) === countPatternWords(selectedValue)) {\n      validateObjectiveStatus();\n    }\n  };\n  element.addEventListener('click', onClick);\n}\n\nexport function showWrongAnswerAnimation(elements: HTMLElement[]): void {\n  const styleId = '#wrong-answer-animation-style';\n\n  executeActions(\"tryAgain.speak='true'\", document.querySelector('#tryAgain'));\n\n  // Check if the style is already added, if not, add it\n  if (!document.querySelector(styleId)) {\n    const style = document.createElement('style');\n    style.id = styleId;\n    style.innerHTML = `\n          @keyframes enhanced-shake {\n              0% { left: 0; }\n              10% { left: -8px; }\n              20% { left: 8px; }\n              30% { left: -8px; }\n              40% { left: 8px; }\n              50% { left: -6px; }\n              60% { left: 6px; }\n              70% { left: -4px; }\n              80% { left: 4px; }\n              90% { left: -2px; }\n              100% { left: 0; }\n          }\n\n          \n          .wrong-answer {\n              position: relative; /* Enable relative positioning to move the element */\n              animation: enhanced-shake 0.6s cubic-bezier(0.36, 0.07, 0.19, 0.97);\n              background-color: #ffdddd; /* Flash red background to indicate wrong answer */\n              box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); /* Subtle red shadow */\n\n              border: 4px solid red;\n          }\n\n          \n      `;\n\n    document.head.appendChild(style);\n  }\n\n  elements.forEach(element => {\n    // Add the class to trigger the animation\n    element.classList.add('wrong-answer');\n\n    // Remove the class after the animation ends to reset the element\n    element.addEventListener(\n      'animationend',\n      () => {\n        element.classList.remove('wrong-answer');\n      },\n      { once: true },\n    );\n  });\n}\n\nfunction handleDropElement(element: HTMLElement): void {\n  // let nextIndex = Object.keys(dropHas).length; // Get next index\n  // dropHas[nextIndex] = { drop: element, isFull: false };\n  let dropHas = JSON.parse(localStorage.getItem(DropHasDrag) || '{}');\n  const tabIndex = element.getAttribute('tabIndex');\n\n  if (typeof dropHas !== 'object' || dropHas === null) {\n    dropHas = {};\n  }\n\n  if (!dropHas[tabIndex]) {\n    dropHas[tabIndex] = { drop: element.id, isFull: false };\n    localStorage.setItem(DropHasDrag, JSON.stringify(dropHas));\n  }\n\n  element.onclick = () => {\n    onClickDropOrDragElement(element, 'drop');\n  };\n  handlingElementFlexibleWidth(element, 'drop');\n}\n\nasync function onClickDropOrDragElement(element: HTMLElement, type: 'drop' | 'drag'): Promise<void> {\n  // Remove the highlight class from elements matching the selector\n  const highlightedElements = document.querySelectorAll(`[type='${type}']`);\n\n  highlightedElements.forEach(el => {\n    removeHighlight(el as HTMLElement);\n  });\n\n  // Dynamically create the highlight class if it doesn't exist\n  if (!document.querySelector('#dynamic-highlight-style')) {\n    const style = document.createElement('style');\n    style.id = 'dynamic-highlight-style';\n    style.innerHTML = `\n      .highlight {\n        // border: 4px solid #e74c3c; /* Thicker red border for more visibility */\n        // border-radius: 12px; /* Larger rounded corners */\n        background-color: rgba(231, 76, 60, 0.3); /* Stronger, more noticeable background */\n        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2), 0 12px 40px rgba(0, 0, 0, 0.2); /* Stronger shadow */\n        outline: 4px solid rgba(231, 76, 60, 0.6); /* Glow effect */\n      }\n    `;\n\n    document.head.appendChild(style);\n  }\n\n  element?.classList.add('highlight');\n  element.ariaPressed = 'true';\n\n  const selectedDropElement: HTMLElement = type === 'drop' ? element : document.querySelector(\"[type='drop'].highlight\");\n  const selectedDragElement: HTMLElement = type === 'drag' ? element : document.querySelector(\"[type='drag'].highlight\");\n\n  if (!selectedDropElement) {\n    onClickDragElement(element);\n  }\n\n  if (selectedDropElement && selectedDragElement) {\n    // Add a transition for a smooth, slower movement\n    (selectedDragElement as HTMLElement).style.transition = 'transform 0.5s ease'; // 0.5s for a slower move\n\n    // Reset the transform of the drag element before calculating the new position\n    (selectedDragElement as HTMLElement).style.transform = '';\n    const container = document.querySelector('#lido-container') as HTMLElement;\n\n    const containerScale = getElementScale(container);\n    console.log('🚀 ~ onClickDropOrDragElement ~ containerScale:', containerScale);\n\n    // Get the positions of the drop and drag elements\n    const dropRect = selectedDropElement.getBoundingClientRect();\n    const dragRect = selectedDragElement.getBoundingClientRect();\n\n    // Calculate the difference in positions\n    const translateX = (dropRect.left - dragRect.left) / containerScale;\n    const translateY = (dropRect.top - dragRect.top) / containerScale;\n\n    // Move the drag element to the drop position\n    selectedDragElement.style.transform = `translate(${translateX}px, ${translateY}px)`;\n\n    // Remove highlights after moving the element\n    const allElements = document.querySelectorAll(`*`);\n    allElements.forEach(el => {\n      removeHighlight(el as HTMLElement);\n    });\n\n    // await new Promise(resolve => setTimeout(resolve, 500));\n    await onElementDropComplete(selectedDragElement, selectedDropElement);\n    // await new Promise(resolve => setTimeout(resolve, 500));\n    // selectedDragElement.style.transform = 'translate(0px, 0px)';\n  }\n}\nconst dragToDropMap = new Map<HTMLElement, HTMLElement | null>();\nasync function onClickDragElement(element) {\n  const dropElements = JSON.parse(localStorage.getItem(DropHasDrag) || '{}') as Record<string, { drop: string; isFull: boolean }>;\n  const dragEl = element;\n  if (!dragEl) {\n    console.error('Element not found');\n    return;\n  }\n  const currentTransform = getComputedStyle(dragEl).transform;\n  removeHighlight(element);\n\n  if (currentTransform && currentTransform !== 'none' && currentTransform !== 'matrix(1, 0, 0, 1, 0, 0)') {\n    dragEl.style.transition = 'transform 0.5s ease';\n    dragEl.style.transform = 'translate(0px, 0px)';\n    onElementDropComplete(dragEl, null);\n    return;\n  }\n\n  let firstFalse = Object.values(dropElements).find(item => !item.isFull);\n  if (firstFalse) {\n    const dropEl = document.querySelector(`#${firstFalse.drop}`) as HTMLElement;\n    dragEl.style.transition = 'transform 0.5s ease';\n    onElementDropComplete(dragEl, dropEl);\n  }\n}\n\nfunction removeHighlight(element: HTMLElement): void {\n  element.classList.remove('highlight');\n  element.ariaPressed = 'false';\n}\n\n// Function to highlight the speaking element\nexport function highlightSpeakingElement(element: HTMLElement): void {\n  if (!element) return;\n\n  // Add a custom class for highlighting\n  element.classList.add('speaking-highlight');\n\n  // Inject keyframe animation and class styles into the document's head if it doesn't already exist\n  const styleId = '#speaking-highlight-style';\n  if (!document.querySelector(styleId)) {\n    const style = document.createElement('style');\n    style.id = styleId;\n    style.innerHTML = `\n      .speaking-highlight {\n        --base-transform: ${element.style.transform};\n        box-shadow: 0 0 20px 10px rgba(255, 165, 0, 0.9) !important; /* Stronger orange glow effect */\n        // border: 3px solid green !important;\n        transition: box-shadow 0.5s ease-in-out, transform 0.5s ease-in-out;\n        transform: scale(1.05); /* Subtle scale effect to pop the element */\n        animation: pulseEffect 1.5s infinite; /* Pulsing animation */\n      }\n\n      @keyframes pulseEffect {\n        0% {\n          box-shadow: 0 0 20px 10px rgba(255, 165, 0, 0.9);\n          transform: var(--base-transform) scale(1.05);\n        }\n        50% {\n          box-shadow: 0 0 30px 15px rgba(255, 165, 0, 1);\n          transform: var(--base-transform) scale(1.1);\n        }\n        100% {\n          box-shadow: 0 0 20px 10px rgba(255, 165, 0, 0.9);\n          transform: var(--base-transform) scale(1.05);\n        }\n      }\n    `;\n    document.head.appendChild(style);\n  }\n}\n\n// Function to stop highlighting\nexport function stopHighlightForSpeakingElement(element: HTMLElement): void {\n  if (!element) return;\n\n  // Remove the custom class for highlighting\n  element.classList.remove('speaking-highlight');\n\n  // Remove inline styles\n  // element.style.boxShadow = '';\n  // element.style.border = '';\n}\n\nexport function convertUrlToRelative(url: string): string {\n  const container = document.querySelector('#lido-container') as HTMLElement;\n  const baseUrl = container.getAttribute('baseUrl');\n\n  if (url.startsWith('http')) {\n    return url;\n  } else if (baseUrl) {\n    return baseUrl + url;\n  } else {\n    return getAssetPath(url);\n  }\n}\n\n/**\n * Asynchronously speaks the given text using the browser's text-to-speech API.\n * Returns true if speech is completed successfully, false otherwise.\n *\n * @param text The text to be spoken.\n * @returns A Promise that resolves to true if speech is successful, or false if an error occurs or speech synthesis is not supported.\n */\nexport async function speakText(text: string, targetElement?: HTMLElement): Promise<boolean> {\n  return new Promise<boolean>((resolve, reject) => {\n    if (!('speechSynthesis' in window)) {\n      reject(new Error('Speech synthesis is not supported in this browser.'));\n      return;\n    }\n\n    const synth = window.speechSynthesis;\n\n    setTimeout(() => {\n      const utterance = new SpeechSynthesisUtterance(text);\n\n      utterance.onend = () => {\n        resolve(true); // Resolve when speech is completed\n      };\n      synth.speak(utterance);\n    }, 50);\n  });\n}\n\nexport function handlingChildElements(element: HTMLElement, minLength: number, maxLength: number, currentLength: number, displayStyle: string) {\n  if (currentLength === undefined) return;\n\n  const children = Array.from(element.children);\n  let allowedLength = currentLength;\n\n  if (minLength && currentLength < minLength) {\n    allowedLength = minLength;\n  }\n  if (maxLength && currentLength > maxLength) {\n    allowedLength = maxLength;\n  }\n\n  children.forEach((child, index) => {\n    (child as HTMLElement).style.display = index < allowedLength ? displayStyle : 'none';\n  });\n}\n\nexport const parseProp = (propValue: string, orientation: string) => {\n  if (!propValue || !propValue.includes(',')) {\n    return propValue;\n  }\n\n  const parsedValues = propValue.split(',').reduce((acc, pair) => {\n    const [key, value] = pair.split('.');\n    acc[key.trim()] = value.trim();\n    return acc;\n  }, {} as Record<string, string>);\n\n  return parsedValues[orientation] || '';\n};\n\nconst handlingElementFlexibleWidth = (element: HTMLElement, type: string) => {\n  const dragElements = document.querySelectorAll(\"[type='drag']\");\n  const dropElements = document.querySelectorAll(\"[type='drop']\");\n  const clickElements = document.querySelectorAll(\"[type='click']\");\n  let maxWidth = 0;\n\n  if (type === 'click') {\n    clickElements.forEach(item => {\n      const clickEl = item as HTMLElement;\n      let targetElement: HTMLElement | null = null;\n\n      if (clickEl.getAttribute('flexibleWidth')) {\n        targetElement = clickEl;\n      } else {\n        // If the parent doesn't have flexibleWidth, check its child elements\n        const childElements = clickEl.children;\n        for (let i = 0; i < childElements.length; i++) {\n          const childEl = childElements[i] as HTMLElement;\n          if (childEl.getAttribute('flexibleWidth')) {\n            targetElement = childEl;\n            break;\n          }\n        }\n      }\n\n      if (targetElement) {\n        // Store original styles before modification\n        const originalWidth = targetElement.style.width;\n        const originalPadding = targetElement.style.padding;\n\n        // Set width to auto and padding to measure actual width\n        targetElement.style.width = 'auto';\n        targetElement.style.padding = '0 20px';\n\n        // Get updated width\n        const tempWidth = targetElement.offsetWidth;\n\n        // Restore original styles\n        targetElement.style.width = originalWidth;\n        targetElement.style.padding = originalPadding;\n\n        // Update max width if the new value is greater\n        if (tempWidth > maxWidth) {\n          maxWidth = tempWidth;\n        }\n      }\n    });\n\n    clickElements.forEach(item => {\n      const clickEl = item as HTMLElement;\n\n      if (clickEl.getAttribute('flexibleWidth')) {\n        if (clickEl.getAttribute('flexibleWidth') === 'true') return;\n        clickEl.style.width = `${maxWidth}px`;\n      } else {\n        const childElements = clickEl.children;\n        for (let i = 0; i < childElements.length; i++) {\n          const childEl = childElements[i] as HTMLElement;\n          if (childEl.getAttribute('flexibleWidth')) {\n            if (childEl.getAttribute('flexibleWidth') === 'true') return;\n            childEl.style.width = `${maxWidth}px`;\n            break;\n          }\n        }\n      }\n    });\n    return;\n  }\n\n  dragElements.forEach(dragItem => {\n    const dragEl = dragItem as HTMLElement;\n\n    const originalWidth = dragEl.style.width;\n    const originalPadding = dragEl.style.padding;\n\n    dragEl.style.width = 'auto';\n    dragEl.style.padding = '0 20px';\n\n    const tempWidth = dragEl.offsetWidth;\n\n    dragEl.style.width = originalWidth;\n    dragEl.style.padding = originalPadding;\n\n    if (tempWidth > maxWidth) {\n      maxWidth = tempWidth;\n    }\n  });\n\n  dragElements.forEach(dragItem => {\n    const dragEl = dragItem as HTMLElement;\n    const isFlexible = dragEl.getAttribute('flexibleWidth');\n\n    if (isFlexible === 'false') {\n      dragEl.style.width = `${maxWidth}px`;\n    } else if (isFlexible === 'true' && type === 'drag') {\n      dragEl.style.width = 'auto';\n      dragEl.style.padding = '0 20px';\n    }\n  });\n\n  dropElements.forEach(dropItem => {\n    const dropEl = dropItem as HTMLElement;\n    const isFlexible = dropEl.getAttribute('flexibleWidth');\n\n    if (isFlexible === 'false') {\n      const borderWidth = parseFloat(getComputedStyle(dropEl).borderWidth);\n\n      if (typeof borderWidth === 'number') {\n        const currentWidth = maxWidth - borderWidth * 2;\n        const currentHeight = parseFloat(dropEl.style.height) - borderWidth * 2;\n        dropEl.style.height = `${currentHeight}px`;\n        dropEl.style.width = `${currentWidth}px`;\n        return;\n      }\n    } else if (isFlexible === 'true' && type === 'drag') {\n      dropEl.style.width = 'auto';\n      dropEl.style.padding = '0 20px';\n    }\n  });\n};\n"],"mappings":"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","ignoreList":[]}