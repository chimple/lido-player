{"version":3,"names":["DragSelectedMapKey","SelectedValuesKey","ActivityScoreKey","ActivityEndKey","LessonEndKey","NextContainerKey","ActivityChangeKey","GameCompletedKey","ElementDropKey","ElementClickKey","TraceMode","GameScore","constructor","this","rightMoves","wrongMoves","finalScore","dispatchCustomEvent","eventName","detail","event","CustomEvent","window","dispatchEvent","dispatchActivityEndEvent","index","totalIndex","score","dispatchLessonEndEvent","dispatchNextContainerEvent","dispatchGameCompletedEvent","dispatchActivityChangeEvent","dispatchElementDropEvent","dragElement","dropElement","isCorrect","createdAt","Date","toISOString","dispatchClickEvent","element","RiveService","getInstance","instance","setRiveInstance","riveInstance","getRiveInstance","gameScore","format","first","middle","last","getElementScale","el","transform","getComputedStyle","matrix","match","matrixValues","split","scaleX","parseFloat","slidingWithScaling","overlapElement","isDragging","startX","startY","initialX","initialY","parentElement","console","error","onStart","removeHighlight","MouseEvent","clientX","clientY","touches","style","opacity","cursor","getBoundingClientRect","document","addEventListener","onMove","onEnd","observer","MutationObserver","mutationsList","mutation","type","attributeName","observerConfig","attributes","attributeFilter","observe","parentElementScale","dx","dy","newLeft","newTop","containerRect","elementRect","numbers","result","map","Number","initialElementLeftPx","left","initialElementTopPx","top","initialElementRightPx","right","initialElementBottomPx","bottom","maxRight","maxLeft","maxTop","maxBottom","newLeftClamp","Math","min","newTopClamp","mostOverlappedElement","findMostoverlappedElement","parent1","parent2","elementPlaceholder","createComment","overlappedPlaceholder","replaceChild","endEv","removeEventListener","slideCompleted","ev","onClickDropOrDragElement","slideElement","slideArr","JSON","parse","localStorage","getItem","allSlideElements","querySelectorAll","forEach","item","setItem","stringify","objectiveString","getElementById","objectiveArray","elementIndex","indexOf","matchStringPattern","trim","storingEachActivityScore","handleShowCheck","enableDraggingWithScaling","container","verticalDistance","horizontalDistance","rect1","rect2","containerScale","width","abs","height","allElements","otherElement","border","backgroundColor","onElementDropComplete","maxOverlapArea","otherRect","overlapWidth","max","overlapHeight","overlapArea","elementArea","otherArea","minimumArea","async","getAttribute","selectedValueData","dragSelectedData","selectedValue","filter","value","dragSelected","key","includes","val","onCorrect","executeActions","onInCorrect","onActivityComplete","actionsString","thisElement","actions","parseActions","i","length","action","targetElement","actor","currentTransform","dropRect","dragRect","scaledLeft","scaledTop","classList","add","audioUrl","convertUrlToRelative","audioElement","newAudio","createElement","id","body","appendChild","pause","currentTime","src","log","play","highlightSpeakingElement","ended","Promise","resolve","setTimeout","stopHighlightForSpeakingElement","isNumber","isNaN","riveService","input","actionStrings","_a","actionString","actorAction","part","lastDotIndex","lastIndexOf","substring","push","replace","pattern","arr","patternGroups","group","arrIndex","options","Set","startsWith","endsWith","choices","slice","option","arrChoice","choice","has","delete","countPatternWords","wordCount","isAllowOnlyCorrect","dragScore","tabindex","sortedKeys","Object","keys","sort","a","b","parseInt","sortedValues","reduce","acc","values","join","flag","calculateScore","floor","storeActivityScore","appHome","querySelector","_b","activityScore","_c","activityScoreKey","toString","scoresArray","cur","removeItem","selectValues","checkButton","showCheck","remove","validateObjectiveStatus","res","appendingDragElementsInDrop","triggerNextContainer","isContinueOnCorrect","dragItems","dropItems","drop","drag","initEventsForElement","canplay","addClickListenerForClickType","handleDropElement","onEntry","onTouchListenerForOnTouch","onTouch","onclick","onClick","objective","isActivated","contains","multiOptionScore","valueToRemove","keyToRemove","find","concat","valueToFind","highlightedElements","innerHTML","head","ariaPressed","selectedDropElement","selectedDragElement","transition","translateX","translateY","styleId","boxShadow","url","baseUrl"],"sources":["src/utils/constants.ts","src/utils/customEvents.ts","src/utils/rive-service.ts","src/utils/utils.ts"],"sourcesContent":["export const DragSelectedMapKey = 'lidoDragSelectedMap';\nexport const SelectedValuesKey = 'lidoSelectedValues';\nexport const ActivityScoreKey = 'lidoActivityScore';\nexport const ActivityEndKey = 'lidoActivityEnd';\nexport const LessonEndKey = 'lidoLessonEnd';\nexport const NextContainerKey = 'lidoNextContainer';\nexport const ActivityChangeKey = 'lidoActivityChange';\nexport const GameCompletedKey = 'lidoGameCompleted';\nexport const GameExitKey = 'lidoGameExit';\nexport const ElementDropKey = 'lidoElementDrop';\nexport const ElementClickKey = 'lidoElementClick';\n\nexport enum TraceMode {\n  NoFlow = 'lido-noFlow',\n  ShowFlow = 'lido-showFlow',\n  FreeTrace = 'lido-freeTrace',\n  BlindTracing = 'lido-blindTracing',\n  BlindFreeTrace = 'lido-blindFreeTrace',\n}\n\nexport default class GameScore{\n  rightMoves: number = 0;\n  wrongMoves: number = 0;\n  finalScore: number = 0;\n}\n","import { ActivityChangeKey, ActivityEndKey, ElementClickKey, ElementDropKey, GameCompletedKey, GameExitKey, LessonEndKey, NextContainerKey } from './constants';\n\nfunction dispatchCustomEvent(eventName: string, detail: any) {\n  const event = new CustomEvent(eventName, { detail });\n  window.dispatchEvent(event);\n}\n\nexport function dispatchActivityEndEvent(index: number, totalIndex: number, score: number) {\n  dispatchCustomEvent(ActivityEndKey, { index, totalIndex, score });\n}\n\nexport function dispatchLessonEndEvent(score: number) {\n  dispatchCustomEvent(LessonEndKey, { score });\n}\n\nexport function dispatchNextContainerEvent() {\n  dispatchCustomEvent(NextContainerKey, {});\n}\n\nexport function dispatchGameCompletedEvent() {\n  dispatchCustomEvent(GameCompletedKey, {});\n}\n\nexport function dispatchGameExitEvent() {\n  dispatchCustomEvent(GameExitKey, {});\n}\n\nexport function dispatchActivityChangeEvent(index: number) {\n  dispatchCustomEvent(ActivityChangeKey, { index });\n}\n\nexport function dispatchElementDropEvent(dragElement: HTMLElement, dropElement: HTMLElement, isCorrect: boolean) {\n  dispatchCustomEvent(ElementDropKey, { dragElement, dropElement, isCorrect: isCorrect, createdAt: new Date().toISOString() });\n}\n\nexport function dispatchClickEvent(element: HTMLElement, isCorrect: boolean) {\n  dispatchCustomEvent(ElementClickKey, { element, isCorrect: isCorrect, createdAt: new Date().toISOString() });\n}\n","// rive-service.ts\nexport class RiveService {\n  private static instance: RiveService;\n  public riveInstance: any;\n\n  private constructor() {}\n\n  public static getInstance() {\n    if (!RiveService.instance) {\n      RiveService.instance = new RiveService();\n    }\n    return RiveService.instance;\n  }\n\n  public setRiveInstance(instance: any) {\n    this.riveInstance = instance;\n  }\n\n  public getRiveInstance() {\n    return this.riveInstance;\n  }\n}\n","import { ActivityScoreKey, DragSelectedMapKey, LessonEndKey, SelectedValuesKey } from './constants';\nimport { dispatchActivityEndEvent, dispatchClickEvent, dispatchElementDropEvent, dispatchLessonEndEvent, dispatchNextContainerEvent } from './customEvents';\nimport GameScore from './constants';\nimport { RiveService } from './rive-service';\nconst gameScore = new GameScore();\n\nexport function format(first?: string, middle?: string, last?: string): string {\n  return (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '');\n}\n\n// Function to get the scale of an element\nconst getElementScale = (el: HTMLElement): number => {\n  const transform = window.getComputedStyle(el).transform;\n  if (transform === 'none') {\n    return 1; // No scaling\n  } else {\n    const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n    if (matrix) {\n      const matrixValues = matrix[1].split(', ');\n      const scaleX = parseFloat(matrixValues[0]);\n      return scaleX; // Assuming uniform scaling (same scale in X and Y)\n    }\n  }\n  return 1; // Fallback to no scaling\n};\n\nfunction slidingWithScaling(element: HTMLElement): void {\n  let overlapElement = false;\n  let isDragging = false;\n  let startX = 0;\n  let startY = 0;\n  let initialX = 0;\n  let initialY = 0;\n\n  // Fetch the container element\n  const parentElement = element.parentElement;\n  if (!parentElement) {\n    console.error(`Parent element not found.`);\n    return;\n  }\n\n  let verticalDistance;\n  let horizontalDistance;\n\n  const onStart = (event: MouseEvent | TouchEvent): void => {\n    removeHighlight(element);\n    isDragging = true;\n\n    if (event instanceof MouseEvent) {\n      startX = event.clientX;\n      startY = event.clientY;\n    } else {\n      startX = event.touches[0].clientX;\n      startY = event.touches[0].clientY;\n    }\n\n    // Apply dragging styles to the element\n    element.style.opacity = '0.8';\n    element.style.cursor = 'grabbing';\n\n    // Parse the current transform values at the start of each drag\n    const transform = window.getComputedStyle(element).transform;\n    if (transform !== 'none') {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        initialX = parseFloat(matrixValues[4]);\n        initialY = parseFloat(matrixValues[5]);\n      }\n    } else {\n      initialX = 0;\n      initialY = 0;\n    }\n\n    const rect1 = parentElement.getBoundingClientRect();\n    const rect2 = element.getBoundingClientRect();\n    verticalDistance = rect1.top - rect2.top;\n    horizontalDistance = rect1.left - rect2.left;\n\n    document.addEventListener('mousemove', onMove);\n    document.addEventListener('mouseup', onEnd);\n    document.addEventListener('touchmove', onMove);\n    document.addEventListener('touchend', onEnd);\n  };\n\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n        const rect1 = parentElement.getBoundingClientRect();\n        const rect2 = element.getBoundingClientRect();\n        verticalDistance = rect1.top - rect2.top;\n        horizontalDistance = rect1.left - rect2.left;\n      }\n    }\n  });\n\n  // Configure the observer to watch for attribute changes\n  const observerConfig = {\n    attributes: true, // Monitor attribute changes\n    attributeFilter: ['style'], // Only observe changes to the 'style' attribute\n  };\n\n  // Start observing the element\n  observer.observe(parentElement, observerConfig);\n\n  const onMove = (event: MouseEvent | TouchEvent): void => {\n    if (!isDragging) return;\n    const parentElementScale = getElementScale(parentElement);\n    let dx = 0;\n    let dy = 0;\n\n    if (event instanceof MouseEvent) {\n      dx = (event.clientX - startX) / parentElementScale;\n      dy = (event.clientY - startY) / parentElementScale;\n    } else {\n      dx = (event.touches[0].clientX - startX) / parentElementScale;\n      dy = (event.touches[0].clientY - startY) / parentElementScale;\n    }\n\n    // Calculate the new position considering scaling\n    const newLeft = initialX + dx;\n    const newTop = initialY + dy;\n\n    // Get the dimensions and scale-corrected position of the container and element\n    const containerRect = parentElement.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n\n    const numbers = element.style.transform.match(/-?\\d+(\\.\\d+)?/g);\n    const result = numbers.map(Number);\n    const initialElementLeftPx = elementRect.left / parentElementScale - result[0];\n    const initialElementTopPx = elementRect.top - result[1];\n    const initialElementRightPx = elementRect.right / parentElementScale - result[0];\n    const initialElementBottomPx = elementRect.bottom - result[1];\n\n    const maxRight = containerRect.right - initialElementRightPx;\n    const maxLeft = containerRect.left - initialElementLeftPx;\n    const maxTop = containerRect.top - initialElementTopPx;\n    const maxBottom = containerRect.bottom - initialElementBottomPx;\n\n    const newLeftClamp = newLeft + initialElementLeftPx <= containerRect.left ? maxLeft : Math.min(newLeft, maxRight);\n    const newTopClamp = newTop + initialElementTopPx <= containerRect.top ? maxTop : Math.min(newTop, maxBottom);\n\n    // Apply transform with translation within boundaries\n    element.style.transform = `translate(${newLeftClamp}px, ${newTopClamp}px)`;\n\n    // Check for overlaps and highlight only the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(element, 'slide');\n\n    // Apply styles only to the most overlapped element\n    if (mostOverlappedElement) {\n      if (mostOverlappedElement != element) {\n        const parent1 = element.parentElement;\n        const parent2 = mostOverlappedElement.parentElement;\n\n        if (parent1 && parent2) {\n          // Temporarily detach both elements\n          const elementPlaceholder = document.createComment('element-placeholder');\n          const overlappedPlaceholder = document.createComment('overlapped-placeholder');\n          parent1.replaceChild(elementPlaceholder, element);\n          parent2.replaceChild(overlappedPlaceholder, mostOverlappedElement);\n          // Swap the elements\n          parent1.replaceChild(mostOverlappedElement, elementPlaceholder);\n          parent2.replaceChild(element, overlappedPlaceholder);\n          element.style.transform = 'translate(0, 0)';\n\n          // Recalculate starting points for the swapped element\n          startX = event instanceof MouseEvent ? event.clientX : event.touches[0].clientX;\n          startY = event instanceof MouseEvent ? event.clientY : event.touches[0].clientY;\n          initialX = 0;\n          initialY = 0;\n          overlapElement = true;\n        }\n      }\n    }\n  };\n\n  const onEnd = (endEv): void => {\n    isDragging = false;\n    document.removeEventListener('mousemove', onMove);\n    document.removeEventListener('mouseup', onEnd);\n    document.removeEventListener('touchmove', onMove);\n    document.removeEventListener('touchend', onEnd);\n\n    // Reset styles when dragging ends\n    element.style.opacity = '';\n    element.style.cursor = 'move';\n    element.style.transform = 'translate(0, 0)';\n\n    if (overlapElement) {\n      slideCompleted(element);\n      overlapElement = false;\n    }\n  };\n  // Initialize draggable element styles\n  element.style.cursor = 'move';\n  element.style.transform = 'translate(0, 0)'; // Initialize transform for consistent dragging\n\n  element.addEventListener('mousedown', onStart);\n  element.addEventListener('touchstart', onStart);\n  element.addEventListener('click', ev => {\n    onClickDropOrDragElement(element, 'drag');\n  });\n}\n\nconst slideCompleted = (slideElement: HTMLElement) => {\n  const slideArr = JSON.parse(localStorage.getItem(SelectedValuesKey)) || [];\n  const allSlideElements = document.querySelectorAll(\"[type='slide']\");\n\n  let index = 0;\n  allSlideElements.forEach(item => {\n    slideArr[index++] = item['value'];\n  });\n  localStorage.setItem(SelectedValuesKey, JSON.stringify(slideArr));\n\n  const objectiveString = document.getElementById('lido-container')['objective'];\n  const objectiveArray = objectiveString.split(',');\n  const elementIndex = slideArr.indexOf(slideElement['value']);\n  const isCorrect = matchStringPattern(slideElement['value'], [objectiveArray[elementIndex].trim()]);\n  storingEachActivityScore(isCorrect);\n  handleShowCheck();\n};\n\nfunction enableDraggingWithScaling(element: HTMLElement): void {\n  let isDragging = false;\n  let startX = 0;\n  let startY = 0;\n  let initialX = 0;\n  let initialY = 0;\n  // Fetch the container element\n  const container = document.getElementById('lido-container');\n  if (!container) {\n    console.error(`Container with ID \"container\" not found.`);\n    return;\n  }\n\n  let verticalDistance;\n  let horizontalDistance;\n\n  const onStart = (event: MouseEvent | TouchEvent): void => {\n    removeHighlight(element);\n    isDragging = true;\n\n    if (event instanceof MouseEvent) {\n      startX = event.clientX;\n      startY = event.clientY;\n    } else {\n      startX = event.touches[0].clientX;\n      startY = event.touches[0].clientY;\n    }\n\n    // Apply dragging styles to the element\n    element.style.opacity = '0.8';\n    element.style.cursor = 'grabbing';\n\n    // Parse the current transform values at the start of each drag\n    const transform = window.getComputedStyle(element).transform;\n    if (transform !== 'none') {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        initialX = parseFloat(matrixValues[4]);\n        initialY = parseFloat(matrixValues[5]);\n      }\n    } else {\n      initialX = 0;\n      initialY = 0;\n    }\n\n    document.addEventListener('mousemove', onMove);\n    document.addEventListener('mouseup', onEnd);\n    document.addEventListener('touchmove', onMove);\n    document.addEventListener('touchend', onEnd);\n  };\n\n  const rect1 = container.getBoundingClientRect();\n  const rect2 = element.getBoundingClientRect();\n  verticalDistance = rect1.top - rect2.top;\n  horizontalDistance = rect1.left - rect2.left;\n\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n        const rect1 = container.getBoundingClientRect();\n        const rect2 = element.getBoundingClientRect();\n        verticalDistance = rect1.top - rect2.top;\n        horizontalDistance = rect1.left - rect2.left;\n      }\n    }\n  });\n\n  // Configure the observer to watch for attribute changes\n  const observerConfig = {\n    attributes: true, // Monitor attribute changes\n    attributeFilter: ['style'], // Only observe changes to the 'style' attribute\n  };\n\n  // Start observing the element\n  observer.observe(container, observerConfig);\n\n  const onMove = (event: MouseEvent | TouchEvent): void => {\n    if (!isDragging) return;\n\n    const containerScale = getElementScale(container);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (event instanceof MouseEvent) {\n      dx = (event.clientX - startX) / containerScale;\n      dy = (event.clientY - startY) / containerScale;\n    } else {\n      dx = (event.touches[0].clientX - startX) / containerScale;\n      dy = (event.touches[0].clientY - startY) / containerScale;\n    }\n\n    // Calculate the new position considering scaling\n    const newLeft = initialX + dx;\n    const newTop = initialY + dy;\n\n    // Get the dimensions and scale-corrected position of the container and element\n    const containerRect = container.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n\n    const numbers = element.style.transform.match(/-?\\d+(\\.\\d+)?/g);\n    const result = numbers.map(Number);\n    const initialElementLeftPx = elementRect.left / containerScale - result[0];\n    const initialElementTopPx = elementRect.top - result[1];\n\n    const maxRight = containerRect.width / containerScale - Math.abs(horizontalDistance / containerScale) - elementRect.width / containerScale;\n    const maxLeft = containerRect.left - initialElementLeftPx;\n    const maxTop = containerRect.top - initialElementTopPx;\n    const maxBottom = containerRect.height / containerScale - Math.abs(verticalDistance / containerScale) - elementRect.height / containerScale;\n\n    const newLeftClamp = newLeft + initialElementLeftPx <= containerRect.left ? maxLeft : Math.min(newLeft, maxRight);\n    const newTopClamp = newTop + initialElementTopPx <= containerRect.top ? maxTop : Math.min(newTop, maxBottom);\n\n    // Apply transform with translation within boundaries\n    element.style.transform = `translate(${newLeftClamp}px, ${newTopClamp}px)`;\n\n    // Check for overlaps and highlight only the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(element, 'drop');\n\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n\n    // Reset styles for all elements\n    allElements.forEach(otherElement => {\n      otherElement.style.border = ''; // Reset border\n      otherElement.style.backgroundColor = ''; // Reset background color\n    });\n\n    // Apply styles only to the most overlapped element\n    if (mostOverlappedElement) {\n      mostOverlappedElement.style.border = '2px dashed #ff0000'; // Red dashed border\n      mostOverlappedElement.style.backgroundColor = 'rgba(255, 0, 0, 0.1)'; // Light red background\n    }\n  };\n\n  const onEnd = (endEv): void => {\n    isDragging = false;\n\n    document.removeEventListener('mousemove', onMove);\n    document.removeEventListener('mouseup', onEnd);\n    document.removeEventListener('touchmove', onMove);\n    document.removeEventListener('touchend', onEnd);\n\n    // Reset styles when dragging ends\n    element.style.opacity = '';\n    element.style.cursor = 'move';\n\n    // Reset overlapping styles from all elements\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n    allElements.forEach(otherElement => {\n      otherElement.style.border = ''; // Reset border\n      otherElement.style.backgroundColor = ''; // Reset background color\n    });\n\n    // Check for overlaps and log the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(element, 'drop');\n\n    onElementDropComplete(element, mostOverlappedElement);\n  };\n  // Initialize draggable element styles\n  element.style.cursor = 'move';\n  element.style.transform = 'translate(0, 0)'; // Initialize transform for consistent dragging\n\n  element.addEventListener('mousedown', onStart);\n  element.addEventListener('touchstart', onStart);\n  element.addEventListener('click', ev => {\n    onClickDropOrDragElement(element, 'drag');\n  });\n}\n\nconst findMostoverlappedElement = (element: HTMLElement, type: string) => {\n  const elementRect = element.getBoundingClientRect();\n  const allElements = document.querySelectorAll<HTMLElement>(`[type=\"${type}\"]`);\n\n  let mostOverlappedElement: HTMLElement | null = null;\n  let maxOverlapArea = 0;\n\n  allElements.forEach(otherElement => {\n    if (otherElement === element) return;\n    const otherRect = otherElement.getBoundingClientRect();\n    // Check if there is overlap\n    const overlapWidth = Math.max(0, Math.min(elementRect.right, otherRect.right) - Math.max(elementRect.left, otherRect.left));\n    const overlapHeight = Math.max(0, Math.min(elementRect.bottom, otherRect.bottom) - Math.max(elementRect.top, otherRect.top));\n    const overlapArea = overlapWidth * overlapHeight;\n\n    if (type === 'slide') {\n      const elementArea = elementRect.width * elementRect.height; // Area of the dragged element\n      const otherArea = otherRect.width * otherRect.height; // Area of the other element\n      // Determine the threshold for overlap (at least 80% of the smaller element's area)\n      const minimumArea = Math.min(elementArea, otherArea) * 0.8;\n\n      // Check if the overlap area exceeds the threshold\n      if (overlapArea >= minimumArea && overlapArea > maxOverlapArea) {\n        maxOverlapArea = overlapArea;\n        mostOverlappedElement = otherElement;\n      }\n      return;\n    }\n\n    // Update the most overlapped element if this one has a larger overlap area\n    if (overlapArea > maxOverlapArea) {\n      maxOverlapArea = overlapArea;\n      mostOverlappedElement = otherElement;\n    }\n  });\n  return mostOverlappedElement;\n};\n\nasync function onElementDropComplete(dragElement: HTMLElement, dropElement: HTMLElement): Promise<void> {\n  if (dropElement && dropElement.getAttribute('isAllowOnlyOneDrop') === 'true') {\n    // Check for overlaps and highlight only the most overlapping element\n    let mostOverlappedElement: HTMLElement = findMostoverlappedElement(dragElement, 'drag');\n    if (mostOverlappedElement) {\n      dragElement.style.transform = 'translate(0,0)';\n      return;\n    }\n  }\n\n  const selectedValueData = localStorage.getItem(SelectedValuesKey);\n  const dragSelectedData = localStorage.getItem(DragSelectedMapKey);\n  if (!dropElement) {\n    if (selectedValueData) {\n      let selectedValue = JSON.parse(selectedValueData);\n      selectedValue = selectedValue.filter(value => value != dragElement['value']);\n      localStorage.setItem(SelectedValuesKey, JSON.stringify(selectedValue));\n    }\n    if (dragSelectedData) {\n      let dragSelected = JSON.parse(dragSelectedData);\n      for (const key in dragSelected) {\n        if (dragSelected[key].includes(dragElement['value'])) {\n          dragSelected[key] = dragSelected[key].filter(val => val !== dragElement['value']);\n        }\n      }\n      localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragSelected));\n    }\n    handleShowCheck();\n    return;\n  }\n\n  if (dragSelectedData) {\n    let dragSelected = JSON.parse(dragSelectedData);\n    for (const key in dragSelected) {\n      if (dragSelected[key].includes(dragElement['value'])) {\n        dragSelected[key] = dragSelected[key].filter(val => val !== dragElement['value']);\n      }\n    }\n    localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragSelected));\n  }\n\n  // Add pulse and highlight effect for a successful match\n  const isCorrect = dropElement['value'].includes(dragElement['value']);\n  dispatchElementDropEvent(dragElement, dropElement, isCorrect);\n  if (isCorrect) {\n    // Perform actions if onMatch is defined\n    const onCorrect = dropElement.getAttribute('onCorrect');\n    if (onCorrect) {\n      await executeActions(onCorrect, dropElement, dragElement);\n    }\n  } else {\n    const onInCorrect = dropElement.getAttribute('onInCorrect');\n\n    await executeActions(onInCorrect, dropElement, dragElement);\n\n    // showWrongAnswerAnimation([dropElement, dragElement]);\n  }\n  storingEachActivityScore(isCorrect);\n  await onActivityComplete(dragElement, dropElement);\n}\n\n// Function to execute actions parsed from the onMatch string\nconst executeActions = async (actionsString: string, thisElement: HTMLElement, element?: HTMLElement): Promise<void> => {\n  const actions = parseActions(actionsString);\n\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i];\n    const targetElement = action.actor === 'this' ? thisElement : action.actor === 'element' ? element : document.getElementById(action.actor);\n\n    if (targetElement) {\n      // Handle the 'transform' property separately\n      switch (action.action) {\n        case 'transform': {\n          const currentTransform = window.getComputedStyle(targetElement).transform;\n          targetElement.style.transform = currentTransform !== 'none' ? `${currentTransform} ${action.value}` : action.value;\n          break;\n        }\n        case 'alignMatch': {\n          const dropElement = targetElement;\n          const dragElement = element;\n\n          const container = document.getElementById('lido-container');\n          const containerScale = getElementScale(container);\n          dragElement.style.transform = 'translate(0,0)';\n          const dropRect = dropElement.getBoundingClientRect();\n          const dragRect = dragElement.getBoundingClientRect();\n\n          const scaledLeft = (dropRect.left - dragRect.left) / containerScale;\n          const scaledTop = (dropRect.top - dragRect.top) / containerScale;\n          dragElement.style.transform = `translate(${scaledLeft}px, ${scaledTop}px)`;\n          break;\n        }\n        case 'addClass': {\n          targetElement.classList.add(action.value);\n          break;\n        }\n        case 'speak': {\n          {\n            let audioUrl = targetElement.getAttribute('audio');\n            if (audioUrl) {\n              audioUrl = convertUrlToRelative(audioUrl);\n              let audioElement = document.getElementById('audio') as HTMLAudioElement;\n              if (!audioElement) {\n                const newAudio = document.createElement('audio');\n                newAudio.id = 'audio';\n                document.body.appendChild(newAudio);\n                audioElement = newAudio;\n              }\n\n              audioElement.pause();\n              audioElement.currentTime = 0;\n              audioElement.src = audioUrl;\n              console.log('ðŸš€ ~ executeActions ~ audioElement.src:', audioElement.src);\n\n              try {\n                await audioElement.play();\n                highlightSpeakingElement(targetElement);\n                while (!audioElement.ended || audioElement.error) {\n                  await new Promise(resolve => setTimeout(resolve, 100));\n                }\n                stopHighlightForSpeakingElement(targetElement);\n              } catch (error) {\n                console.log('ðŸš€ ~ executeActions ~ audioElement.src: error', error);\n              }\n            }\n            break;\n          }\n        }\n\n        case 'sleep': {\n          const isNumber = !isNaN(Number(action.value));\n          if (isNumber) {\n            await new Promise(resolve => setTimeout(resolve, Number(action.value)));\n          }\n          break;\n        }\n\n        case 'avatarAnimate': {\n          const riveService = RiveService.getInstance();\n          const riveInstance = riveService.getRiveInstance();\n\n          if (riveInstance && action.value) {\n            riveInstance.play(action.value);\n          }\n          break;\n        }\n\n        default: {\n          targetElement.style[action.action] = action.value;\n          break;\n        }\n      }\n    }\n  }\n};\n\n// Function to parse actions string\nconst parseActions = (input: string): Array<{ actor: string; action: string; value: string }> => {\n  const actions = [];\n  if (!input) return actions;\n  const actionStrings = input.split(';')?.map(action => action.trim());\n\n  actionStrings.forEach(actionString => {\n    if (actionString) {\n      const [actorAction, value] = actionString.split('=').map(part => part.trim());\n      const lastDotIndex = actorAction.lastIndexOf('.');\n      if (lastDotIndex !== -1) {\n        const actor = actorAction.substring(0, lastDotIndex).trim();\n        const action = actorAction.substring(lastDotIndex + 1).trim();\n        actions.push({ actor, action, value: value.replace(/['\"]/g, '') });\n      }\n    }\n  });\n\n  return actions;\n};\n\nconst matchStringPattern = (pattern: string, arr: string[]): boolean => {\n  const patternGroups = pattern.split(',').map(group => group.trim());\n\n  let arrIndex = 0;\n  let options = new Set<string>();\n\n  for (const group of patternGroups) {\n    if (group.startsWith('(') && group.endsWith(')')) {\n      // Inside parentheses: '|' acts like \"OR\" condition\n      const choices = group\n        .slice(1, -1)\n        .split('|')\n        .map(option => option.trim());\n\n      const arrChoice = group\n        .slice(1, -1)\n        .split('|')\n        .map(option => option.trim());\n\n      if (arrIndex >= arrChoice.length) return false;\n      if (!choices.includes(arrChoice[arrIndex])) return false;\n\n      arrIndex++;\n    } else if (group.includes('|')) {\n      // Outside parentheses: '|' acts as optional order\n      const choices = group.split('|').map(option => option.trim());\n\n      for (const choice of choices) {\n        options.add(choice);\n      }\n    } else {\n      // Exact match required\n      if (arrIndex >= arr.length || arr[arrIndex] !== group) return false;\n\n      arrIndex++;\n    }\n  }\n\n  // Validate the optional ordered items against the remaining array elements\n  while (arrIndex < arr.length) {\n    if (!options.has(arr[arrIndex])) {\n      return false;\n    }\n    options.delete(arr[arrIndex]);\n    arrIndex++;\n  }\n\n  return arrIndex === arr.length;\n};\n\nconst countPatternWords = (pattern: string): number => {\n  const patternGroups = pattern.split(',').map(group => group.trim());\n\n  let wordCount = 0;\n\n  for (const group of patternGroups) {\n    if (group.startsWith('(') && group.endsWith(')')) {\n      if(group.includes('|')){\n        wordCount += group.split('|').length;\n      }else{\n        wordCount += 1;\n      }\n    } else {\n      wordCount += group.split('|').length;\n    }\n  }\n\n  return wordCount;\n};\n\nasync function onActivityComplete(dragElement?: HTMLElement, dropElement?: HTMLElement) {\n  const container = document.getElementById('lido-container');\n  if (!container) return;\n\n  const isAllowOnlyCorrect = container.getAttribute('isAllowOnlyCorrect') === 'true';\n  if (isAllowOnlyCorrect) {\n    const isCorrect = dropElement['value'].includes(dragElement['value']);\n    if (!isCorrect) {\n      dragElement.style.transform = 'translate(0,0)';\n      return;\n    }\n  }\n\n  await executeActions(\"this.alignMatch='true'\", dropElement, dragElement);\n\n  let dragScore = JSON.parse(localStorage.getItem(DragSelectedMapKey) ?? '{}');\n  const tabindex = dropElement.getAttribute('tabindex');\n\n  if (!dragScore[tabindex]) {\n    dragScore[tabindex] = [];\n  }\n\n  dragScore[tabindex].push(dragElement['value']);\n\n  localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragScore));\n\n  const sortedKeys = Object.keys(dragScore).sort((a, b) => parseInt(a) - parseInt(b));\n\n  const sortedValues = sortedKeys.reduce((acc, key) => {\n    const values = dragScore[key];\n    if (values.length > 1) {\n      acc.push(`(${values.join('|')})`);\n    } else {\n      acc.push(values[0]);\n    }\n    return acc;\n  }, []);\n\n  localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n\n  handleShowCheck();\n}\n\nconst storingEachActivityScore = (flag: boolean) => {\n  if (flag) {\n    gameScore.rightMoves += 1;\n  } else {\n    gameScore.wrongMoves += 1;\n  }\n  console.log('Right Moves : ', gameScore.rightMoves);\n  console.log('Wrong Moves : ', gameScore.wrongMoves);\n};\n\nconst calculateScore = () => {\n  const rightMoves = gameScore.rightMoves;\n  const wrongMoves = gameScore.wrongMoves;\n  let finalScore = Math.floor((rightMoves / (rightMoves + wrongMoves)) * 100);\n  storeActivityScore(finalScore);\n  gameScore.rightMoves = 0;\n  gameScore.wrongMoves = 0;\n};\n\nconst storeActivityScore = (score: number) => {\n  const appHome = document.querySelector('lido-home');\n  if (!appHome) return;\n  const index = Number(appHome.getAttribute('index') ?? 0);\n  const totalIndex = Number(appHome.getAttribute('totalIndex') ?? 0);\n\n  const activityScore = JSON.parse(localStorage.getItem(ActivityScoreKey) ?? '{}');\n  const activityScoreKey = index.toString();\n  activityScore[activityScoreKey] = score;\n\n  //send Custom Event to parent\n  // window.dispatchEvent(new CustomEvent(ActivityEndKey, { detail: { index: index, totalIndex: totalIndex, score: score } }));\n  dispatchActivityEndEvent(index, totalIndex, score);\n\n  localStorage.setItem(ActivityScoreKey, JSON.stringify(activityScore));\n  if (totalIndex - 1 == index) {\n    const scoresArray: number[] = Object.values(activityScore);\n    const finalScore = scoresArray.reduce((acc, cur) => acc + cur, 0) / scoresArray.length;\n    gameScore.finalScore = Math.floor(finalScore);\n    console.log('Total Score : ', gameScore.finalScore);\n    // window.dispatchEvent(new CustomEvent(LessonEndKey, { detail: { score: finalScore } }));\n    dispatchLessonEndEvent(finalScore);\n    localStorage.removeItem(ActivityScoreKey);\n  }\n};\n\nconst handleShowCheck = () => {\n  const container = document.getElementById('lido-container');\n  const objectiveString = container['objective'];\n  const selectValues = localStorage.getItem(SelectedValuesKey) ?? '';\n\n  const checkButton = document.getElementById('lido-checkButton');\n  \n  if (!selectValues || countPatternWords(selectValues) !== countPatternWords(objectiveString)) {\n    executeActions(\"this.addClass='lido-disable-check-button'\", checkButton);\n    return;\n  }\n\n  const showCheck = container.getAttribute('showCheck') == 'true';\n\n  if (showCheck) {\n    checkButton.classList.remove('lido-disable-check-button');\n  } else {\n    validateObjectiveStatus();\n  }\n};\n\nconst validateObjectiveStatus = async () => {\n  const container = document.getElementById('lido-container');\n  if (!container) return;\n  const objectiveString = container['objective'];\n  const objectiveArray = JSON.parse(localStorage.getItem(SelectedValuesKey)) ?? [];\n  const res = matchStringPattern(objectiveString, objectiveArray);\n\n  if (res) {\n    appendingDragElementsInDrop();\n    const onCorrect = container.getAttribute('onCorrect');\n    if (onCorrect) {\n      await executeActions(onCorrect, container);\n    }\n    triggerNextContainer();\n  } else {\n    const onInCorrect = container.getAttribute('onInCorrect');\n    await executeActions(onInCorrect, container);\n    const isContinueOnCorrect = container.getAttribute('isContinueOnCorrect') === 'true';\n    if (!isContinueOnCorrect) {\n      triggerNextContainer();\n    }\n  }\n  await calculateScore();\n};\n\nconst appendingDragElementsInDrop = () => {\n  const dragItems = document.querySelectorAll(\"[type='drag']\");\n  const dropItems = document.querySelectorAll(\"[type='drop']\");\n  if (!dragItems || !dropItems) return;\n  dropItems.forEach(drop => {\n    dragItems.forEach(dragElement => {\n      const drag = dragElement as HTMLElement;\n      if (drop['value'].includes(drag[\"value\"])) {\n        drag.style.transform = 'translate(0,0)';\n        drop.appendChild(drag);\n      }\n    });\n  });\n};\n\nexport const triggerNextContainer = () => {\n  // const event = new CustomEvent('nextContainer');\n  console.log('ðŸš€ ~ triggerNextContainer ~ event:', event);\n  // window.dispatchEvent(event);\n  dispatchNextContainerEvent();\n};\n\nexport const initEventsForElement = async (element: HTMLElement, type: string) => {\n  const container = document.getElementById('lido-container');\n  if (!container) return;\n  const canplay = container.getAttribute('canplay');\n  if (canplay != null && canplay === 'false') return;\n  switch (type) {\n    case 'drag': {\n      enableDraggingWithScaling(element);\n      break;\n    }\n    case 'click': {\n      addClickListenerForClickType(element);\n      break;\n    }\n    case 'drop': {\n      handleDropElement(element);\n      break;\n    }\n    case 'slide': {\n      slidingWithScaling(element);\n      break;\n    }\n    default:\n      break;\n  }\n  const onEntry = element.getAttribute('onEntry');\n  await executeActions(onEntry, element);\n\n  onTouchListenerForOnTouch(element);\n};\n\nfunction onTouchListenerForOnTouch(element: HTMLElement) {\n  if (!element) return;\n  const onTouch = element.getAttribute('onTouch');\n  if (!onTouch) return;\n  element.onclick = async () => {\n    console.log('ðŸš€ ~ element.onclick= ~ onTouch:', onTouch);\n    if (!onTouch) return;\n    await executeActions(onTouch, element);\n  };\n}\n\nfunction addClickListenerForClickType(element: HTMLElement): void {\n  element.style.cursor = 'pointer';\n  if (!element) {\n    console.error('No element provided.');\n    return;\n  }\n\n  const onClick = async () => {\n    const container = document.getElementById('lido-container');\n    const objective = container['objective'].split(',');\n    const checkButton = document.getElementById('lido-checkButton');\n\n    if (element.getAttribute('id') == 'lido-checkButton') {\n      validateObjectiveStatus();\n      return;\n    }\n\n    // element.style.border = '2px solid yellow';\n    // element.style.boxShadow = '0px 0px 10px rgba(255, 255, 0, 0.7)';\n\n    // element.style.transition = 'transform 0.2s ease, border 0.5s ease';\n    // element.style.transform = 'scale(1.1)';\n\n    // element.style.transform = 'scale(1)';\n    // element.style.border = '';\n    // element.style.boxShadow = '';\n\n    const isActivated = element.classList.contains('lido-element-selected');\n    let selectedValue = JSON.parse(localStorage.getItem(SelectedValuesKey)) || [];\n\n    if (isActivated) {\n      element.classList.remove('lido-element-selected');\n      executeActions(element.getAttribute('onEntry'), element);\n\n      selectedValue = selectedValue.filter(item => item != element['value']);\n      localStorage.setItem(SelectedValuesKey, JSON.stringify(selectedValue));\n\n      let multiOptionScore = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n      const valueToRemove = element['value'];\n      const keyToRemove = Object.keys(multiOptionScore).find(key => multiOptionScore[key].includes(valueToRemove));\n\n      if (keyToRemove) {\n        multiOptionScore[keyToRemove] = multiOptionScore[keyToRemove].filter(item => item !== valueToRemove);\n        if (multiOptionScore[keyToRemove].length === 0) {\n          delete multiOptionScore[keyToRemove];\n        }\n        localStorage.setItem(DragSelectedMapKey, JSON.stringify(multiOptionScore));\n        const sortedKeys = Object.keys(multiOptionScore).sort((a, b) => parseInt(a) - parseInt(b));\n        const sortedValues = sortedKeys.reduce((acc, key) => acc.concat(multiOptionScore[key]), []);\n        localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n      }\n      checkButton.classList.add('lido-disable-check-button');\n      return;\n    } else {\n      if (objective.length > selectedValue.length) {\n        element.classList.add('lido-element-selected');\n        const isCorrect = objective.includes(element['value']);\n        dispatchClickEvent(element, isCorrect);\n        if (isCorrect) {\n          const onCorrect = element.getAttribute('onCorrect');\n          await executeActions(onCorrect, element);\n        } else {\n          const onInCorrect = element.getAttribute('onInCorrect');\n          await executeActions(onInCorrect, element);\n          // showWrongAnswerAnimation([element]);\n        }\n        storingEachActivityScore(isCorrect);\n\n        const valueToFind = element['value'];\n        const key = Object.keys(objective).find(key => objective[key] === valueToFind);\n        let multiOptionScore = JSON.parse(localStorage.getItem(DragSelectedMapKey)) || {};\n        if (!key) {\n          multiOptionScore[objective.length + selectedValue.length] = [valueToFind];\n        } else {\n          multiOptionScore[key] = [valueToFind];\n        }\n        localStorage.setItem(DragSelectedMapKey, JSON.stringify(multiOptionScore));\n        const sortedKeys = Object.keys(multiOptionScore).sort((a, b) => parseInt(a) - parseInt(b));\n        const sortedValues = sortedKeys.reduce((acc, key) => acc.concat(multiOptionScore[key]), []);\n        localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n      }\n    }\n\n    handleShowCheck();\n  };\n  element.addEventListener('click', onClick);\n}\n\nexport function showWrongAnswerAnimation(elements: HTMLElement[]): void {\n  const styleId = 'wrong-answer-animation-style';\n\n  executeActions(\"tryAgain.speak='true'\", document.getElementById('tryAgain'));\n\n  // Check if the style is already added, if not, add it\n  if (!document.getElementById(styleId)) {\n    const style = document.createElement('style');\n    style.id = styleId;\n    style.innerHTML = `\n          @keyframes enhanced-shake {\n              0% { left: 0; }\n              10% { left: -8px; }\n              20% { left: 8px; }\n              30% { left: -8px; }\n              40% { left: 8px; }\n              50% { left: -6px; }\n              60% { left: 6px; }\n              70% { left: -4px; }\n              80% { left: 4px; }\n              90% { left: -2px; }\n              100% { left: 0; }\n          }\n\n          \n          .wrong-answer {\n              position: relative; /* Enable relative positioning to move the element */\n              animation: enhanced-shake 0.6s cubic-bezier(0.36, 0.07, 0.19, 0.97);\n              background-color: #ffdddd; /* Flash red background to indicate wrong answer */\n              box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); /* Subtle red shadow */\n\n              border: 4px solid red;\n          }\n\n          \n      `;\n\n    document.head.appendChild(style);\n  }\n\n  elements.forEach(element => {\n    // Add the class to trigger the animation\n    element.classList.add('wrong-answer');\n\n    // Remove the class after the animation ends to reset the element\n    element.addEventListener(\n      'animationend',\n      () => {\n        element.classList.remove('wrong-answer');\n      },\n      { once: true },\n    );\n  });\n}\n\nfunction handleDropElement(element: HTMLElement): void {\n  element.onclick = () => {\n    onClickDropOrDragElement(element, 'drop');\n  };\n}\n\nasync function onClickDropOrDragElement(element: HTMLElement, type: 'drop' | 'drag'): Promise<void> {\n  // Remove the highlight class from elements matching the selector\n  const highlightedElements = document.querySelectorAll(`[type='${type}']`);\n\n  highlightedElements.forEach(el => {\n    removeHighlight(el as HTMLElement);\n  });\n\n  // Dynamically create the highlight class if it doesn't exist\n  if (!document.getElementById('dynamic-highlight-style')) {\n    const style = document.createElement('style');\n    style.id = 'dynamic-highlight-style';\n    style.innerHTML = `\n      .highlight {\n        border: 4px solid #e74c3c; /* Thicker red border for more visibility */\n        border-radius: 12px; /* Larger rounded corners */\n        background-color: rgba(231, 76, 60, 0.3); /* Stronger, more noticeable background */\n        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2), 0 12px 40px rgba(0, 0, 0, 0.2); /* Stronger shadow */\n        outline: 4px solid rgba(231, 76, 60, 0.6); /* Glow effect */\n      }\n    `;\n\n    document.head.appendChild(style);\n  }\n\n  element?.classList.add('highlight');\n  element.ariaPressed = 'true';\n\n  const selectedDropElement: HTMLElement = type === 'drop' ? element : document.querySelector(\"[type='drop'].highlight\");\n  const selectedDragElement: HTMLElement = type === 'drag' ? element : document.querySelector(\"[type='drag'].highlight\");\n\n  if (selectedDropElement && selectedDragElement) {\n    // Add a transition for a smooth, slower movement\n    (selectedDragElement as HTMLElement).style.transition = 'transform 0.5s ease'; // 0.5s for a slower move\n\n    // Reset the transform of the drag element before calculating the new position\n    (selectedDragElement as HTMLElement).style.transform = '';\n    const container = document.getElementById('lido-container');\n\n    const containerScale = getElementScale(container);\n    console.log('ðŸš€ ~ onClickDropOrDragElement ~ containerScale:', containerScale);\n\n    // Get the positions of the drop and drag elements\n    const dropRect = selectedDropElement.getBoundingClientRect();\n    const dragRect = selectedDragElement.getBoundingClientRect();\n\n    // Calculate the difference in positions\n    const translateX = (dropRect.left - dragRect.left) / containerScale;\n    const translateY = (dropRect.top - dragRect.top) / containerScale;\n\n    // Move the drag element to the drop position\n    selectedDragElement.style.transform = `translate(${translateX}px, ${translateY}px)`;\n\n    // Remove highlights after moving the element\n    const allElements = document.querySelectorAll(`*`);\n    allElements.forEach(el => {\n      removeHighlight(el as HTMLElement);\n    });\n\n    // await new Promise(resolve => setTimeout(resolve, 500));\n    await onElementDropComplete(selectedDragElement, selectedDropElement);\n    // await new Promise(resolve => setTimeout(resolve, 500));\n    // selectedDragElement.style.transform = 'translate(0px, 0px)';\n  }\n}\n\nfunction removeHighlight(element: HTMLElement): void {\n  element.classList.remove('highlight');\n  element.ariaPressed = 'false';\n}\n\n// Function to highlight the speaking element\nfunction highlightSpeakingElement(element: HTMLElement): void {\n  if (!element) return;\n\n  // Add a custom class for highlighting\n  element.classList.add('speaking-highlight');\n\n  // Inject keyframe animation and class styles into the document's head if it doesn't already exist\n  const styleId = 'speaking-highlight-style';\n  if (!document.getElementById(styleId)) {\n    const style = document.createElement('style');\n    style.id = styleId;\n    style.innerHTML = `\n      .speaking-highlight {\n        box-shadow: 0 0 20px 10px rgba(255, 165, 0, 0.9); /* Stronger orange glow effect */\n        border: 3px solid orange;\n        transition: box-shadow 0.5s ease-in-out, transform 0.5s ease-in-out;\n        transform: scale(1.05); /* Subtle scale effect to pop the element */\n        animation: pulseEffect 1.5s infinite; /* Pulsing animation */\n      }\n\n      @keyframes pulseEffect {\n        0% {\n          box-shadow: 0 0 20px 10px rgba(255, 165, 0, 0.9);\n          transform: scale(1.05);\n        }\n        50% {\n          box-shadow: 0 0 30px 15px rgba(255, 165, 0, 1);\n          transform: scale(1.1);\n        }\n        100% {\n          box-shadow: 0 0 20px 10px rgba(255, 165, 0, 0.9);\n          transform: scale(1.05);\n        }\n      }\n    `;\n    document.head.appendChild(style);\n  }\n}\n\n// Function to stop highlighting\nfunction stopHighlightForSpeakingElement(element: HTMLElement): void {\n  if (!element) return;\n\n  // Remove the custom class for highlighting\n  element.classList.remove('speaking-highlight');\n\n  // Remove inline styles\n  element.style.boxShadow = '';\n  element.style.border = '';\n}\n\nexport function convertUrlToRelative(url: string): string {\n  //check if url is web\n  if (url.startsWith('http')) {\n    return url;\n  }\n  const container = document.getElementById('lido-container');\n  if (!container) return url;\n  const baseUrl = container.getAttribute('baseUrl');\n  if (!baseUrl) return url;\n  return baseUrl + url;\n}\n"],"mappings":"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","ignoreList":[]}