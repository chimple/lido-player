{"version":3,"names":["format","first","middle","last","enableDraggingWithScaling","element","isDragging","startX","startY","initialX","initialY","container","document","getElementById","console","error","getElementScale","el","transform","window","getComputedStyle","matrix","match","matrixValues","split","scaleX","parseFloat","onStart","event","MouseEvent","clientX","clientY","touches","addEventListener","onMove","onEnd","rect1","getBoundingClientRect","rect2","verticalDistance","top","horizontalDistance","left","observer","MutationObserver","mutationsList","mutation","type","attributeName","observerConfig","attributes","attributeFilter","observe","containerScale","dx","dy","newLeft","newTop","containerRect","elementRect","numbers","style","result","map","Number","initialElementLeftPx","initialElementTopPx","maxRight","width","Math","abs","maxLeft","maxTop","maxBottom","height","newLeftClamp","min","newTopClamp","removeEventListener","cursor"],"sources":["src/utils/utils.ts"],"sourcesContent":["export function format(first?: string, middle?: string, last?: string): string {\n  return (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '');\n}\n\nexport function enableDraggingWithScaling(element: HTMLElement): void {\n  let isDragging = false;\n  let startX = 0;\n  let startY = 0;\n  let initialX = 0;\n  let initialY = 0;\n\n  // Fetch the container element\n  const container = document.getElementById('container');\n  if (!container) {\n    console.error(`Container with ID \"container\" not found.`);\n    return;\n  }\n\n  // Function to get the scale of an element\n  const getElementScale = (el: HTMLElement): number => {\n    const transform = window.getComputedStyle(el).transform;\n    if (transform === 'none') {\n      return 1; // No scaling\n    } else {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        const scaleX = parseFloat(matrixValues[0]);\n        return scaleX; // Assuming uniform scaling (same scale in X and Y)\n      }\n    }\n    return 1; // Fallback to no scaling\n  };\n\n  const onStart = (event: MouseEvent | TouchEvent): void => {\n    isDragging = true;\n\n    if (event instanceof MouseEvent) {\n      startX = event.clientX;\n      startY = event.clientY;\n    } else {\n      startX = event.touches[0].clientX;\n      startY = event.touches[0].clientY;\n    }\n\n    // Parse the current transform values at the start of each drag\n    const transform = window.getComputedStyle(element).transform;\n    if (transform !== 'none') {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        initialX = parseFloat(matrixValues[4]);\n        initialY = parseFloat(matrixValues[5]);\n      }\n    } else {\n      initialX = 0;\n      initialY = 0;\n    }\n\n    document.addEventListener('mousemove', onMove);\n    document.addEventListener('mouseup', onEnd);\n    document.addEventListener('touchmove', onMove);\n    document.addEventListener('touchend', onEnd);\n  };\n\n  const rect1 = container.getBoundingClientRect();\n  const rect2 = element.getBoundingClientRect();\n\n  let verticalDistance = rect1.top - rect2.top;\n  let horizontalDistance = rect1.left - rect2.left;\n\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n        const rect1 = container.getBoundingClientRect();\n        const rect2 = element.getBoundingClientRect();\n        verticalDistance = rect1.top - rect2.top;\n        horizontalDistance = rect1.left - rect2.left;\n      }\n    }\n  });\n\n  // Configure the observer to watch for attribute changes\n  const observerConfig = {\n    attributes: true, // Monitor attribute changes\n    attributeFilter: ['style'], // Only observe changes to the 'style' attribute\n  };\n\n  // Start observing the element\n  observer.observe(container, observerConfig);\n\n  // Output the distance\n\n  const onMove = (event: MouseEvent | TouchEvent): void => {\n    if (!isDragging) return;\n\n    const containerScale = getElementScale(container);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (event instanceof MouseEvent) {\n      dx = (event.clientX - startX) / containerScale;\n      dy = (event.clientY - startY) / containerScale;\n    } else {\n      dx = (event.touches[0].clientX - startX) / containerScale;\n      dy = (event.touches[0].clientY - startY) / containerScale;\n    }\n\n    // Calculate the new position considering scaling\n    const newLeft = initialX + dx;\n    const newTop = initialY + dy;\n\n    // Get the dimensions and scale-corrected position of the container and element\n    const containerRect = container.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n\n    const numbers = element.style.transform.match(/-?\\d+(\\.\\d+)?/g);\n\n    const result = numbers.map(Number);\n    const initialElementLeftPx = elementRect.left / containerScale - result[0];\n    const initialElementTopPx = elementRect.top - result[1];\n\n    const maxRight = containerRect.width / containerScale - Math.abs(horizontalDistance / containerScale) - elementRect.width / containerScale;\n    const maxLeft = containerRect.left - initialElementLeftPx;\n    const maxTop = containerRect.top - initialElementTopPx;\n    const maxBottom = containerRect.height / containerScale - Math.abs(verticalDistance / containerScale) - elementRect.height / containerScale;\n\n    const newLeftClamp = newLeft + initialElementLeftPx <= containerRect.left ? maxLeft : Math.min(newLeft, maxRight);\n\n    const newTopClamp = newTop + initialElementTopPx <= containerRect.top ? maxTop : Math.min(newTop, maxBottom);\n    // Apply transform with translation within boundaries\n    element.style.transform = `translate(${newLeftClamp}px, ${newTopClamp}px)`;\n  };\n\n  const onEnd = (): void => {\n    isDragging = false;\n    document.removeEventListener('mousemove', onMove);\n    document.removeEventListener('mouseup', onEnd);\n    document.removeEventListener('touchmove', onMove);\n    document.removeEventListener('touchend', onEnd);\n  };\n\n  // Initialize draggable element styles\n  element.style.cursor = 'move';\n  element.style.transform = 'translate(0, 0)'; // Initialize transform for consistent dragging\n\n  element.addEventListener('mousedown', onStart);\n  element.addEventListener('touchstart', onStart);\n}\n"],"mappings":"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","ignoreList":[]}