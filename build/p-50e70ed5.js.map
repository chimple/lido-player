{"version":3,"names":["DragSelectedMapKey","SelectedValuesKey","format","first","middle","last","enableDraggingWithScaling","element","isDragging","startX","startY","initialX","initialY","container","document","getElementById","console","error","getElementScale","el","transform","window","getComputedStyle","matrix","match","matrixValues","split","scaleX","parseFloat","onStart","event","MouseEvent","clientX","clientY","touches","style","opacity","cursor","addEventListener","onMove","onEnd","rect1","getBoundingClientRect","rect2","verticalDistance","top","horizontalDistance","left","observer","MutationObserver","mutationsList","mutation","type","attributeName","observerConfig","attributes","attributeFilter","observe","containerScale","dx","dy","newLeft","newTop","containerRect","elementRect","numbers","result","map","Number","initialElementLeftPx","initialElementTopPx","maxRight","width","Math","abs","maxLeft","maxTop","maxBottom","height","newLeftClamp","min","newTopClamp","allElements","querySelectorAll","mostOverlappedElement","maxOverlapArea","forEach","otherElement","otherRect","overlapWidth","max","right","overlapHeight","bottom","overlapArea","border","backgroundColor","removeEventListener","log","getAttribute","dragScore","JSON","parse","_a","localStorage","getItem","setItem","stringify","sortedKeys","Object","keys","sort","a","b","parseInt","sortedValues","reduce","acc","key","concat","applyPulseAndHighlightEffect","setTimeout","transition","boxShadow","onMatch","executeActions","onActivityComplete","actionsString","dropElement","dragElement","actions","parseActions","action","targetElement","actor","value","input","actionStrings","trim","actionString","actorAction","part","lastDotIndex","lastIndexOf","substring","push","replace","matchStringPattern","pattern","arr","patternGroups","group","arrIndex","options","Set","startsWith","endsWith","choices","slice","option","length","includes","choice","add","has","delete","objectiveString","objectiveArray","res","removeItem","triggerNextContainer","CustomEvent","dispatchEvent","initEventsForElement","addClickListener","onClick","objective","onTouch"],"sources":["src/utils/constants.ts","src/utils/utils.ts"],"sourcesContent":["export const DragSelectedMapKey = 'dragSelectedMap';\nexport const SelectedValuesKey = 'selectedValues';\n","import { DragSelectedMapKey, SelectedValuesKey } from './constants';\n\nexport function format(first?: string, middle?: string, last?: string): string {\n  return (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '');\n}\n\nfunction enableDraggingWithScaling(element: HTMLElement): void {\n  let isDragging = false;\n  let startX = 0;\n  let startY = 0;\n  let initialX = 0;\n  let initialY = 0;\n\n  // Fetch the container element\n  const container = document.getElementById('container');\n  if (!container) {\n    console.error(`Container with ID \"container\" not found.`);\n    return;\n  }\n\n  // Function to get the scale of an element\n  const getElementScale = (el: HTMLElement): number => {\n    const transform = window.getComputedStyle(el).transform;\n    if (transform === 'none') {\n      return 1; // No scaling\n    } else {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        const scaleX = parseFloat(matrixValues[0]);\n        return scaleX; // Assuming uniform scaling (same scale in X and Y)\n      }\n    }\n    return 1; // Fallback to no scaling\n  };\n\n  const onStart = (event: MouseEvent | TouchEvent): void => {\n    isDragging = true;\n\n    if (event instanceof MouseEvent) {\n      startX = event.clientX;\n      startY = event.clientY;\n    } else {\n      startX = event.touches[0].clientX;\n      startY = event.touches[0].clientY;\n    }\n\n    // Apply dragging styles to the element\n    element.style.opacity = '0.8';\n    element.style.cursor = 'grabbing';\n\n    // Parse the current transform values at the start of each drag\n    const transform = window.getComputedStyle(element).transform;\n    if (transform !== 'none') {\n      const matrix = transform.match(/matrix\\(([^)]+)\\)/);\n      if (matrix) {\n        const matrixValues = matrix[1].split(', ');\n        initialX = parseFloat(matrixValues[4]);\n        initialY = parseFloat(matrixValues[5]);\n      }\n    } else {\n      initialX = 0;\n      initialY = 0;\n    }\n\n    document.addEventListener('mousemove', onMove);\n    document.addEventListener('mouseup', onEnd);\n    document.addEventListener('touchmove', onMove);\n    document.addEventListener('touchend', onEnd);\n  };\n\n  const rect1 = container.getBoundingClientRect();\n  const rect2 = element.getBoundingClientRect();\n\n  let verticalDistance = rect1.top - rect2.top;\n  let horizontalDistance = rect1.left - rect2.left;\n\n  const observer = new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n        const rect1 = container.getBoundingClientRect();\n        const rect2 = element.getBoundingClientRect();\n        verticalDistance = rect1.top - rect2.top;\n        horizontalDistance = rect1.left - rect2.left;\n      }\n    }\n  });\n\n  // Configure the observer to watch for attribute changes\n  const observerConfig = {\n    attributes: true, // Monitor attribute changes\n    attributeFilter: ['style'], // Only observe changes to the 'style' attribute\n  };\n\n  // Start observing the element\n  observer.observe(container, observerConfig);\n\n  const onMove = (event: MouseEvent | TouchEvent): void => {\n    if (!isDragging) return;\n\n    const containerScale = getElementScale(container);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (event instanceof MouseEvent) {\n      dx = (event.clientX - startX) / containerScale;\n      dy = (event.clientY - startY) / containerScale;\n    } else {\n      dx = (event.touches[0].clientX - startX) / containerScale;\n      dy = (event.touches[0].clientY - startY) / containerScale;\n    }\n\n    // Calculate the new position considering scaling\n    const newLeft = initialX + dx;\n    const newTop = initialY + dy;\n\n    // Get the dimensions and scale-corrected position of the container and element\n    const containerRect = container.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n\n    const numbers = element.style.transform.match(/-?\\d+(\\.\\d+)?/g);\n    const result = numbers.map(Number);\n    const initialElementLeftPx = elementRect.left / containerScale - result[0];\n    const initialElementTopPx = elementRect.top - result[1];\n\n    const maxRight = containerRect.width / containerScale - Math.abs(horizontalDistance / containerScale) - elementRect.width / containerScale;\n    const maxLeft = containerRect.left - initialElementLeftPx;\n    const maxTop = containerRect.top - initialElementTopPx;\n    const maxBottom = containerRect.height / containerScale - Math.abs(verticalDistance / containerScale) - elementRect.height / containerScale;\n\n    const newLeftClamp = newLeft + initialElementLeftPx <= containerRect.left ? maxLeft : Math.min(newLeft, maxRight);\n    const newTopClamp = newTop + initialElementTopPx <= containerRect.top ? maxTop : Math.min(newTop, maxBottom);\n\n    // Apply transform with translation within boundaries\n    element.style.transform = `translate(${newLeftClamp}px, ${newTopClamp}px)`;\n\n    // Check for overlaps and highlight only the most overlapping element\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n    let mostOverlappedElement: HTMLElement | null = null;\n    let maxOverlapArea = 0;\n\n    allElements.forEach(otherElement => {\n      const otherRect = otherElement.getBoundingClientRect();\n\n      // Check if there is overlap\n      const overlapWidth = Math.max(0, Math.min(elementRect.right, otherRect.right) - Math.max(elementRect.left, otherRect.left));\n      const overlapHeight = Math.max(0, Math.min(elementRect.bottom, otherRect.bottom) - Math.max(elementRect.top, otherRect.top));\n      const overlapArea = overlapWidth * overlapHeight;\n\n      // Update the most overlapped element if this one has a larger overlap area\n      if (overlapArea > maxOverlapArea) {\n        maxOverlapArea = overlapArea;\n        mostOverlappedElement = otherElement;\n      }\n    });\n\n    // Reset styles for all elements\n    allElements.forEach(otherElement => {\n      otherElement.style.border = ''; // Reset border\n      otherElement.style.backgroundColor = ''; // Reset background color\n    });\n\n    // Apply styles only to the most overlapped element\n    if (mostOverlappedElement) {\n      mostOverlappedElement.style.border = '2px dashed #ff0000'; // Red dashed border\n      mostOverlappedElement.style.backgroundColor = 'rgba(255, 0, 0, 0.1)'; // Light red background\n    }\n  };\n\n  const onEnd = (): void => {\n    isDragging = false;\n    document.removeEventListener('mousemove', onMove);\n    document.removeEventListener('mouseup', onEnd);\n    document.removeEventListener('touchmove', onMove);\n    document.removeEventListener('touchend', onEnd);\n\n    // Reset styles when dragging ends\n    element.style.opacity = '';\n    element.style.cursor = 'move';\n\n    // Reset overlapping styles from all elements\n    const allElements = document.querySelectorAll<HTMLElement>(\"[type='drop']\");\n    allElements.forEach(otherElement => {\n      otherElement.style.border = ''; // Reset border\n      otherElement.style.backgroundColor = ''; // Reset background color\n    });\n\n    // Check for overlaps and log the most overlapping element\n    const elementRect = element.getBoundingClientRect();\n    let mostOverlappedElement: HTMLElement | null = null;\n    let maxOverlapArea = 0;\n\n    allElements.forEach(otherElement => {\n      const otherRect = otherElement.getBoundingClientRect();\n\n      // Calculate overlap\n      const overlapWidth = Math.max(0, Math.min(elementRect.right, otherRect.right) - Math.max(elementRect.left, otherRect.left));\n      const overlapHeight = Math.max(0, Math.min(elementRect.bottom, otherRect.bottom) - Math.max(elementRect.top, otherRect.top));\n      const overlapArea = overlapWidth * overlapHeight;\n\n      // Update the most overlapped element if this one has a larger overlap area\n      if (overlapArea > maxOverlapArea) {\n        maxOverlapArea = overlapArea;\n        mostOverlappedElement = otherElement;\n      }\n    });\n\n    if (!mostOverlappedElement) return;\n\n    console.log('Most overlapping element:', mostOverlappedElement.getAttribute('tabindex'), mostOverlappedElement['tabindex'], element['value']);\n\n    let dragScore = JSON.parse(localStorage.getItem(DragSelectedMapKey) ?? '{}');\n    if (!dragScore[mostOverlappedElement.getAttribute('tabindex')]) {\n      dragScore[mostOverlappedElement.getAttribute('tabindex')] = [];\n    }\n    // dragScore[mostOverlappedElement.getAttribute('tabindex')].push(element['value']);\n    dragScore[mostOverlappedElement.getAttribute('tabindex')] = [element['value']];\n\n    localStorage.setItem(DragSelectedMapKey, JSON.stringify(dragScore));\n    const sortedKeys = Object.keys(dragScore).sort((a, b) => parseInt(a) - parseInt(b));\n    const sortedValues = sortedKeys.reduce((acc, key) => acc.concat(dragScore[key]), []);\n    console.log('ðŸš€ ~ onEnd ~ dragScore:', dragScore, sortedValues);\n    localStorage.setItem(SelectedValuesKey, JSON.stringify(sortedValues));\n\n    // Add pulse and highlight effect for a successful match\n    if (mostOverlappedElement['value'] === element['value']) {\n      console.log('ðŸš€ ~ onEnd ~ mostOverlappedElement onMatch:', mostOverlappedElement['onMatch']);\n\n      // Apply a pulse and highlight effect\n      applyPulseAndHighlightEffect(mostOverlappedElement);\n      applyPulseAndHighlightEffect(element);\n\n      // Delay the execution of the action to show the effects\n      setTimeout(() => {\n        // Reset the visual effect after the delay\n        mostOverlappedElement.style.transition = '';\n        mostOverlappedElement.style.boxShadow = '';\n        mostOverlappedElement.style.backgroundColor = '';\n        element.style.transition = '';\n        element.style.boxShadow = '';\n        element.style.backgroundColor = '';\n\n        // Perform actions if onMatch is defined\n        const onMatch = mostOverlappedElement.getAttribute('onMatch');\n        if (onMatch) {\n          executeActions(onMatch, mostOverlappedElement, element);\n        }\n      }, 1000); // Adjust the delay time as needed (1000ms in this case)\n    }\n\n    onActivityComplete();\n  };\n\n  // Function to apply a pulse and highlight effect using inline styles\n  const applyPulseAndHighlightEffect = (el: HTMLElement): void => {\n    // Apply a longer background color change to light green and pulse effect\n    el.style.transition = 'box-shadow 0.5s ease, background-color 0.5s ease';\n    el.style.backgroundColor = 'rgba(144, 238, 144, 0.7)'; // Light green color\n\n    // Apply a subtle pulse effect using box-shadow\n    el.style.boxShadow = '0 0 15px 7px rgba(144, 238, 144, 0.5)'; // Light green shadow\n\n    // Reset box-shadow after the effect duration\n    setTimeout(() => {\n      el.style.boxShadow = '0 0 0px 0px rgba(144, 238, 144, 0.0)'; // Reset shadow\n    }, 500); // Extended duration for the pulse effect\n  };\n\n  // Initialize draggable element styles\n  element.style.cursor = 'move';\n  element.style.transform = 'translate(0, 0)'; // Initialize transform for consistent dragging\n\n  element.addEventListener('mousedown', onStart);\n  element.addEventListener('touchstart', onStart);\n}\n\n// Function to execute actions parsed from the onMatch string\nconst executeActions = (actionsString: string, dropElement: HTMLElement, dragElement?: HTMLElement): void => {\n  console.log('ðŸš€ ~ executeActions ~ actionsString:', actionsString);\n  const actions = parseActions(actionsString);\n  console.log('ðŸš€ ~ executeActions ~ actions:', actions);\n  actions.forEach(action => {\n    const targetElement = action.actor === 'this' ? dropElement : action.actor === 'element' ? dragElement : document.getElementById(action.actor);\n    console.log('ðŸš€ ~ executeActions ~ targetElement:', targetElement, action.action);\n    if (targetElement) {\n      targetElement.style[action.action] = action.value;\n    }\n  });\n};\n\n// Function to parse actions string\nconst parseActions = (input: string): Array<{ actor: string; action: string; value: string }> => {\n  const actions = [];\n  const actionStrings = input.split(';').map(action => action.trim());\n\n  actionStrings.forEach(actionString => {\n    if (actionString) {\n      const [actorAction, value] = actionString.split('=').map(part => part.trim());\n      const lastDotIndex = actorAction.lastIndexOf('.');\n      if (lastDotIndex !== -1) {\n        const actor = actorAction.substring(0, lastDotIndex).trim();\n        const action = actorAction.substring(lastDotIndex + 1).trim();\n        actions.push({ actor, action, value: value.replace(/['\"]/g, '') });\n      }\n    }\n  });\n\n  return actions;\n};\n\nconst matchStringPattern = (pattern: string, arr: string[]): boolean => {\n  const patternGroups = pattern.split(',').map(group => group.trim());\n\n  let arrIndex = 0;\n  let options = new Set<string>();\n\n  for (const group of patternGroups) {\n    if (group.startsWith('(') && group.endsWith(')')) {\n      // Inside parentheses: '|' acts like \"OR\" condition\n      const choices = group\n        .slice(1, -1)\n        .split('|')\n        .map(option => option.trim());\n\n      if (arrIndex >= arr.length) return false;\n\n      if (!choices.includes(arr[arrIndex])) return false;\n\n      arrIndex++;\n    } else if (group.includes('|')) {\n      // Outside parentheses: '|' acts as optional order\n      const choices = group.split('|').map(option => option.trim());\n\n      for (const choice of choices) {\n        options.add(choice);\n      }\n    } else {\n      // Exact match required\n      if (arrIndex >= arr.length || arr[arrIndex] !== group) return false;\n\n      arrIndex++;\n    }\n  }\n\n  // Validate the optional ordered items against the remaining array elements\n  while (arrIndex < arr.length) {\n    if (!options.has(arr[arrIndex])) {\n      return false;\n    }\n    options.delete(arr[arrIndex]);\n    arrIndex++;\n  }\n\n  return arrIndex === arr.length;\n};\n\nconst countPatternWords = (pattern: string): number => {\n  const patternGroups = pattern.split(',').map(group => group.trim());\n\n  let wordCount = 0;\n\n  for (const group of patternGroups) {\n    if (group.startsWith('(') && group.endsWith(')')) {\n      wordCount += 1;\n    } else {\n      wordCount += group.split('|').length;\n    }\n  }\n\n  return wordCount;\n};\n\nfunction onActivityComplete() {\n  const container = document.getElementById('container');\n  if (!container) return;\n  const objectiveString = container['objective'];\n  const objectiveArray = JSON.parse(localStorage.getItem(SelectedValuesKey) ?? '[]');\n  const res = matchStringPattern(objectiveString, objectiveArray);\n  console.log('ðŸš€ ~ onActivityComplete ~ res:', res, objectiveString, objectiveArray);\n  if (res) {\n    localStorage.removeItem(SelectedValuesKey);\n    localStorage.removeItem(DragSelectedMapKey);\n\n    setTimeout(() => {\n      triggerNextContainer();\n    }, 1500);\n  }\n}\n\nexport const triggerNextContainer = () => {\n  const event = new CustomEvent('nextContainer');\n  console.log('ðŸš€ ~ triggerNextContainer ~ event:', event);\n  window.dispatchEvent(event);\n};\n\nexport const initEventsForElement = (element: HTMLElement, type: string) => {\n  switch (type) {\n    case 'drag': {\n      enableDraggingWithScaling(element);\n      break;\n    }\n    case 'click': {\n      addClickListener(element);\n      break;\n    }\n    default:\n      break;\n  }\n};\n\nfunction addClickListener(element: HTMLElement): void {\n  element.style.cursor = 'pointer';\n  if (!element) {\n    console.error('No element provided.');\n    return;\n  }\n\n  const onClick = () => {\n    console.log('Element clicked:', element);\n    localStorage.setItem(SelectedValuesKey, JSON.stringify([element['value']]));\n    element.style.border = '2px solid yellow';\n    element.style.boxShadow = '0px 0px 10px rgba(255, 255, 0, 0.7)';\n\n    element.style.transition = 'transform 0.2s ease, border 0.5s ease';\n    element.style.transform = 'scale(1.1)';\n\n    setTimeout(() => {\n      element.style.transform = 'scale(1)';\n      element.style.border = '';\n      element.style.boxShadow = '';\n      const container = document.getElementById('container');\n      const objective = container['objective'];\n      if (objective && element['value'] === objective) {\n        const onTouch = element.getAttribute('onTouch');\n        executeActions(onTouch, element);\n      }\n    }, 500);\n    onActivityComplete();\n  };\n  element.addEventListener('click', onClick);\n}\n"],"mappings":"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","ignoreList":[]}