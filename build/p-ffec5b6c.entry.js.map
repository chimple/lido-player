{"version":3,"names":["lidoColCss","LidoColStyle0","LidoCol","componentDidLoad","initEventsForElement","this","el","type","render","style","height","width","backgroundColor","bgColor","top","y","left","x","display","visible","zIndex","z","h","Host","key","id","class","tabindex","tabIndex","value","ariaLabel","ariaHidden","audio","onTouch","onCorrect","onInCorrect","onEntry","lidoContainerCss","LidoContainerStyle0","LidoContainer","scaleContainer","container","widths","window","innerWidth","_a","screen","push","Math","min","document","documentElement","clientHeight","scaleX","scaleY","scale","transform","body","addEventListener","position","console","log","canplay","objective","showCheck","isContinueOnCorrect","indexCss","LidoHomeStyle0","animationCss","LidoHomeStyle1","lidoHomeCss","LidoHomeStyle2","LidoHome","NextContainerKey","index","undefined","currentContainerIndex","localStorage","removeItem","SelectedValuesKey","DragSelectedMapKey","containers","length","dispatchActivityChangeEvent","showCompletionMessage","dispatchGameCompletedEvent","setTimeout","initialIndex","componentWillLoad","e","detail","parseXMLData","xmlData","disconnectedCallback","removeEventListener","parser","DOMParser","xmlDoc","parseFromString","rootElement","parseContainers","parseElement","element","tagName","nodeName","toLowerCase","props","Array","from","attributes","forEach","attr","name","children","childNodes","map","child","nodeType","textContent","trim","filter","Boolean","componentMapping","Object","assign","baseUrl","warn","containerElements","querySelectorAll","parsedElement","renderDots","_","onClick","jumpToContainer","totalIndex","lidoImageCss","LidoImageStyle0","LidoImage","alignItems","justifyContent","src","convertUrlToRelative","alt","lidoPosCss","LidoPosStyle0","LidoPos","lidoRandomCss","LidoRandomStyle0","LidoRandom","slotElements","randomTop","random","randomLeft","LidoRoot","xmlPath","resolvedPath","startsWith","getAssetPath","response","fetch","ok","Error","statusText","data","text","error","lidoRowCss","LidoRowStyle0","LidoRow","lidoShapeCss","LidoShapeStyle0","LidoShape","shapeType","lidoTextCss","LidoTextStyle0","LidoText","fontSize","fontFamily","font","color","fontColor","isAllowOnlyOneDrop","string","lidoTraceCss","LidoTraceStyle0","LidoTrace","initializeSVG","state","fileIndex","currentPathIndex","lastLength","totalPathLength","isDragging","circle","paths","svg","proximityThreshold","freeTraceProximityThreshold","rafId","pointerMoveEvent","activePointerId","mode","flowMarkers","freeTraceLines","loadAnotherSVG","fetchSVG","url","calculateBoundingBox","padding","minX","Infinity","minY","maxX","maxY","path","getTotalLength","numPoints","i","point","getPointAtLength","insertSVG","svgText","svgContainer","getElementById","innerHTML","svgElement","querySelector","removeAttribute","bbox","viewBoxWidth","viewBoxHeight","setAttribute","getSVGElement","getPaths","createFlowMarkersForPath","markerCount","totalLength","interval","markers","nextPoint","angle","atan2","arrowMarker","createElementNS","PI","parentNode","appendChild","updateFlowIndicators","indicators","indicator","TraceMode","NoFlow","ShowFlow","setupDrawingPath","pathLength","greenPath","cloneNode","toString","classList","add","BlindTracing","BlindFreeTrace","setupDraggableCircle","firstPathStart","addEventListeners","evt","preventDefault","pointerPos","getPointerPosition","circlePos","parseFloat","getAttribute","distance","getDistanceSquared","pointerId","setPointerCapture","requestAnimationFrame","handlePointerMove","_b","_c","_d","currentPath","proximitySquared","FreeTrace","distanceSquared","closestPoint","getClosestPointOnPath","distanceToPathSquared","currentFreePath","newPath","lastPointerPos","previousPos","newPathData","midPointX","midPointY","updatedPathData","currentPathLength","distanceToEnd","moveToNextPath","triggerNextContainer","svgPoint","createSVGPoint","clientX","clientY","ctm","getScreenCTM","inverse","matrixTransform","p1","p2","dx","dy","pathNode","minDistanceSquared","coarseStep","coarseClosestPoint","coarseMinDistanceSquared","pointOnPath","fineStep","searchStart","max","searchEnd","isNext","cleanupPreviousSVG","svgSource","removeChild","remove","nextPath","startPoint","lidoWrapCss","LidoWrapStyle0","LidoWrap"],"sources":["src/components/column/lido-col.css?tag=lido-col","src/components/column/lido-col.tsx","src/components/container/lido-container.css?tag=lido-container","src/components/container/lido-container.tsx","src/index.css?tag=lido-home","src/utils/css/animation.css?tag=lido-home","src/components/home/lido-home.css?tag=lido-home","src/components/home/lido-home.tsx","src/components/image/lido-image.css?tag=lido-image","src/components/image/lido-image.tsx","src/components/position/lido-pos.css?tag=lido-pos","src/components/position/lido-pos.tsx","src/components/random/lido-random.css?tag=lido-random","src/components/random/lido-random.tsx","src/components/root/lido-root.tsx","src/components/row/lido-row.css?tag=lido-row","src/components/row/lido-row.tsx","src/components/shape/lido-shape.css?tag=lido-shape","src/components/shape/lido-shape.tsx","src/components/text/lido-text.css?tag=lido-text","src/components/text/lido-text.tsx","src/components/trace/lido-trace.css?tag=lido-trace","src/components/trace/lido-trace.tsx","src/components/wrap/lido-wrap.css?tag=lido-wrap","src/components/wrap/lido-wrap.tsx"],"sourcesContent":[".lido-col {\n  /* position: absolute; */\n  top: var(--y, 0);\n  left: var(--x, 0);\n  height: var(--height, 100%);\n  width: var(--width, 100%);\n  background-color: var(--bgColor, #eeeeee);\n  /* position: relative; */\n  padding: 15px;\n  border-radius: 10px;\n  display: flex;\n  justify-content: space-around;\n  flex-direction: column;\n  align-items: center;\n}\n\n.lido-col > * {\n  /* position: relative; */\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoCol\n *\n * The `LidoCol` component is a dynamic column-like UI element that can be\n * customized via various properties such as dimensions, position, visibility,\n * background color, and event handlers. It is designed to work within\n * containers (`lido-container`) and can include child components like\n * `lido-text`, `lido-row`, etc.\n */\n@Component({\n  tag: 'lido-col',\n  styleUrl: 'lido-col.css',\n  shadow: false,\n})\nexport class LidoCol {\n  /**\n   * The unique identifier for the column component.\n   */\n  @Prop() id: string;\n\n  /**\n   * The value associated with the column component. Typically used for internal logic.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the column component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the column component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * The x-coordinate (left position) of the column within its container (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * The y-coordinate (top position) of the column within its container (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * The z-index of the column to control stacking order.\n   */\n  @Prop() z: string;\n\n  /**\n   * The background color of the column (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Defines the type of the column, which can be used for styling or specific logic handling.\n   */\n  @Prop() type: string;\n\n  /**\n   * The tab index value, used to set the tab order of the column for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * A boolean that controls whether the column is visible (`true`) or hidden (`false`).\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * Audio file URL or identifier for sound that will be associated with the column.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler for a touch event, where a custom function can be triggered when the column is touched.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler for when the column is entered, which can be used to initiate specific behaviors on entry.\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Reference to the HTML element that represents this component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * This lifecycle hook is called after the component is rendered in the DOM.\n   * It initializes events for the column based on the provided type.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles applied to the column, mainly for positioning and background.\n    const style = {\n      height: this.height,\n      width: this.width,\n      backgroundColor: this.bgColor,\n      top: this.y,\n      left: this.x,\n      display: this.visible ? 'flex' : 'none',\n      zIndex: this.z,\n    };\n\n    return (\n      <Host\n        id={this.id}\n        class=\"lido-col\"\n        type={this.type}\n        tabindex={this.tabIndex}\n        value={this.value}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        <slot />\n      </Host>\n    );\n  }\n}\n",".lido-container {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  background-color: var(--bgColor, #ffffff);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoContainer\n *\n * The `LidoContainer` component acts as a container for other elements. It scales responsively\n * based on the window size, adjusts background color, and provides various configurable properties\n * such as dimensions, positioning, visibility, and custom event handlers.\n */\n@Component({\n  tag: 'lido-container',\n  styleUrl: 'lido-container.css',\n  shadow: false,\n})\nexport class LidoContainer{\n  /**\n   * Unique identifier for the container.\n   */\n  @Prop() id: string;\n\n  /**\n   * Objective or purpose of the container. Can be used for internal logic or tracking.\n   */\n  @Prop() objective: string;\n\n  /**\n   * Value assigned to the container. This can be used for logic related to this component.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the container (CSS value).\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the container (CSS value).\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the container.\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the container.\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index to control the stacking order of the container.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the container (CSS color value).\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Type of the container, which can be used for conditional logic or styling purposes.\n   */\n  @Prop() type: string;\n\n  /**\n   * TabIndex for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Visibility flag for the container. If `true`, the container is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier of an audio file associated with the container.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the container is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the container is entered, useful for triggering animations or logic.\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Boolean that controls the playability of the game.\n   */\n  @Prop() canplay: boolean = true;\n\n  /**\n   * Indicates whether the \"Check\" button should be visible or not. Expected values: \"true\" or \"false\".\n   */\n  @Prop() showCheck: string;\n\n  /**\n   * Specifies whether the activity should continue automatically upon a correct response. Expected values: \"true\" or \"false\".\n   */\n  @Prop() isContinueOnCorrect: string;\n\n  /**\n   * Base URL for the container.\n   */\n  @Prop() baseUrl: string = '';\n\n  /**\n   * Reference to the HTML element that represents this container component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Scales the container based on the window or screen size, maintaining the aspect ratio.\n   * The container scales according to the minimum dimension of the screen.\n   *\n   * @param container The container element to be scaled.\n   */\n  scaleContainer(container: HTMLElement) {\n    const widths = [window.innerWidth];\n    const heights = [window.innerHeight];\n\n    if (window.screen?.width) {\n      widths.push(window.screen.width);\n      heights.push(window.screen.height);\n    }\n\n    const width = Math.min(...widths);\n    const height = document.documentElement.clientHeight;\n\n    const scaleX = width / 1600; // Scale based on a reference width of 1600px\n    const scaleY = height / 900; // Scale based on a reference height of 900px\n    const scale = Math.min(scaleX, scaleY);\n\n    // Center the container and apply scaling\n    container.style.transform = `translate(-50%, -50%) scale(${scale})`;\n  }\n\n  /**\n   * Lifecycle hook that runs after the component is loaded.\n   * - It scales the container.\n   * - It sets the background color of the body.\n   * - Adds event listeners for `resize` and `load` to rescale the container on window size changes.\n   */\n  componentDidLoad() {\n    this.scaleContainer(this.el);\n    document.body.style.backgroundColor = this.bgColor;\n\n    // Re-scale the container on window resize or load events\n    window.addEventListener('resize', () => this.scaleContainer(this.el));\n    window.addEventListener('load', () => this.scaleContainer(this.el));\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Define the styles for the container element\n    const style = {\n      backgroundColor: this.bgColor,\n      width: '1600px', // Fixed width of the container\n      height: '900px', // Fixed height of the container\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)', // Centering the container\n    };\n    console.log('ðŸš€ ~ LidoContainer ~ canplay:', this.canplay);\n\n    return (\n      <Host\n        id=\"lido-container\"\n        tabindex={0}\n        class=\"lido-container\"\n        objective={this.objective}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        onTouch={this.onTouch}\n        onInCorrect={this.onInCorrect}\n        onCorrect={this.onCorrect}\n        onEntry={this.onEntry}\n        showCheck={this.showCheck}\n        isContinueOnCorrect={this.isContinueOnCorrect}\n        canplay={`${this.canplay}`}\n      >\n        <slot />\n      </Host>\n    );\n  }\n}\n","@import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');\n\nbody {\n  overflow: hidden;\n}\n\n.lido-disable-check-button {\n  pointer-events: none;\n  background-color: #9393935c !important;\n  color: white;\n}\n","/* animations */\n\n@keyframes rightToPlace {\n  from {\n    transform: translateX(2000px);\n  }\n  to {\n    left: 0;\n  }\n}\n\n@keyframes placeToLeft {\n  from {\n  }\n  to {\n    transform: translateX(-2000px);\n  }\n}\n\n@keyframes shake {\n  0% {\n    transform: translateX(0);\n  }\n  10% {\n    transform: translateX(-5px);\n  }\n  20% {\n    transform: translateX(5px);\n  }\n  30% {\n    transform: translateX(-5px);\n  }\n  40% {\n    transform: translateX(5px);\n  }\n  50% {\n    transform: translateX(-5px);\n  }\n  60% {\n    transform: translateX(5px);\n  }\n  70% {\n    transform: translateX(-5px);\n  }\n  80% {\n    transform: translateX(5px);\n  }\n  90% {\n    transform: translateX(-5px);\n  }\n  100% {\n    transform: translateX(0);\n  }\n}\n\n@keyframes fallAndBounce {\n  0% {\n    transform: translateY(-1000px);\n  }\n  25% {\n    transform: translateY(0px);\n  }\n  50% {\n    transform: translateY(-200px);\n  }\n  75% {\n    transform: translateY(0);\n  }\n  90% {\n    transform: translateY(-100px);\n  }\n  100% {\n    transform: translateY(0);\n  }\n}\n\n@keyframes placeToDown {\n  0% {\n    transform: translateY(0);\n  }\n  100% {\n    transform: translateY(1000px);\n  }\n}\n\n",".lido-snackbar {\n  visibility: visible;\n  min-width: 250px;\n  background-color: #333;\n  color: #fff;\n  text-align: center;\n  border-radius: 2px;\n  padding: 16px;\n  position: fixed;\n  z-index: 1;\n  bottom: 30px;\n  left: 50%;\n  transform: translateX(-50%);\n  font-size: 17px;\n}\n\n.lido-dot-container {\n  text-align: center;\n  position: fixed;\n  z-index: 1;\n  width: fit-content;\n  top: 1%;\n  left: 50%;\n  transform: translate(-50%);\n}\n\n.lido-dot {\n  height: 15px;\n  width: 15px;\n  margin: 0 4px;\n  background-color: #bbb;\n  border-radius: 50%;\n  display: inline-block;\n  transition: background-color 0.3s;\n  cursor: pointer;\n}\n\n.lido-dot.completed {\n  background-color: grey;\n}\n\n.lido-dot.current {\n  background-color: green;\n}\n\n.lido-dot:not(.completed):not(.current) {\n  background-color: #bbb;\n}\n","import { Component, Prop, h, State, Host } from '@stencil/core';\nimport { DragSelectedMapKey, SelectedValuesKey, NextContainerKey } from '../../utils/constants';\nimport { dispatchActivityChangeEvent, dispatchGameCompletedEvent } from '../../utils/customEvents';\n\n/**\n * @component LidoHome\n *\n * The `LidoHome` component renders a series of containers parsed from the provided XML data.\n * It handles navigation between containers, resets the state on page reloads or container transitions,\n * and displays progress indicators (dots) for each container.\n */\n@Component({\n  tag: 'lido-home',\n  shadow: false,\n  styleUrls: ['./../../index.css', '../../utils/css/animation.css', './lido-home.css'],\n})\nexport class LidoHome {\n  /**\n   * XML data passed to the component, which is parsed and used to render various containers.\n   */\n  @Prop() xmlData: string;\n\n  /**\n   * Initial index of the container being displayed.\n   */\n  @Prop() initialIndex: number = 0;\n\n  /**\n   * Boolean that controls the playability of the game.\n   */\n  @Prop() canplay: boolean = true;\n\n  /**\n   * Base URL for the containers.\n   */\n  @Prop() baseUrl: string = '';\n\n  /**\n   * Current index of the container being displayed.\n   */\n  @State() currentContainerIndex: number = this.initialIndex;\n\n  /**\n   * Boolean that controls the display of the completion message after all containers have been viewed.\n   */\n  @State() showCompletionMessage: boolean = false;\n\n  /**\n   * Array that stores the parsed containers from the XML data.\n   */\n  @State() containers: any[] = [];\n\n  /**\n   * Event handler for transitioning to the next container in the sequence.\n   * If the last container is reached, it shows a completion message.\n   */\n  NextContainerKey = (index?: number | undefined) => {\n    if (index != undefined && index == this.currentContainerIndex) return;\n    // Clear selected values from localStorage on container transition\n    localStorage.removeItem(SelectedValuesKey);\n    localStorage.removeItem(DragSelectedMapKey);\n\n    if (index != undefined && index < this.containers.length) {\n      // Move to the next container\n      this.currentContainerIndex = index;\n      // window.dispatchEvent(new CustomEvent('activityChange', { detail: { index: this.currentContainerIndex } }));\n      dispatchActivityChangeEvent(this.currentContainerIndex);\n    } else if (this.currentContainerIndex < this.containers.length - 1) {\n      // Move to the next container\n      this.currentContainerIndex++;\n      // window.dispatchEvent(new CustomEvent('activityChange', { detail: { index: this.currentContainerIndex } }));\n      dispatchActivityChangeEvent(this.currentContainerIndex);\n    } else if (this.currentContainerIndex >= this.containers.length - 1) {\n      // Show the completion message if all containers have been viewed\n      this.showCompletionMessage = true;\n      // const event = new CustomEvent('gameCompleted');\n      // window.dispatchEvent(event);\n      dispatchGameCompletedEvent();\n\n      this.currentContainerIndex = 0;\n      // Hide the completion message after 3 seconds\n      setTimeout(() => {\n        this.showCompletionMessage = false;\n      }, 3000);\n    }\n\n    // Reset the containers array to trigger a re-render\n    this.containers = [...this.containers];\n  };\n\n  /**\n   * Lifecycle method that runs before the component is loaded. It sets up event listeners for transitioning\n   * between containers and parses the XML data into containers.\n   */\n  componentWillLoad() {\n    // Listen for 'NextContainerKey' event to transition between containers\n    window.addEventListener(NextContainerKey, () => {\n      this.NextContainerKey();\n    });\n\n    window.addEventListener('changeContainer', (e: any) => {\n      this.NextContainerKey(e.detail.index);\n    });\n\n    // Parse the provided XML data\n    this.parseXMLData(this.xmlData);\n\n    // Remove stored values in localStorage when the page is about to be unloaded\n    window.addEventListener('beforeunload', () => {\n      localStorage.removeItem(SelectedValuesKey);\n      localStorage.removeItem(DragSelectedMapKey);\n    });\n  }\n\n  /**\n   * Lifecycle method that cleans up event listeners when the component is removed from the DOM.\n   */\n  disconnectedCallback() {\n    window.removeEventListener(NextContainerKey, () => {\n      this.NextContainerKey();\n    });\n    window.removeEventListener('changeContainer', (e: any) => {\n      this.NextContainerKey(e.detail.index);\n    });\n  }\n\n  /**\n   * Parses the provided XML string into an XML DOM object and extracts the containers from it.\n   *\n   * @param xmlData - The XML data as a string.\n   */\n  private parseXMLData(xmlData: string) {\n    if (xmlData) {\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(xmlData, 'text/xml');\n      const rootElement = xmlDoc.documentElement;\n\n      // Parse containers from the root XML element\n      this.parseContainers(rootElement);\n    }\n  }\n\n  /**\n   * Recursively parses an XML element and its children, converting them into corresponding Stencil components.\n   *\n   * @param element - The XML element to parse.\n   * @returns The corresponding Stencil component with parsed props and children.\n   */\n  private parseElement(element: Element): any {\n    const tagName = element.nodeName.toLowerCase();\n    const props: { [key: string]: any } = {};\n\n    // Extract attributes from the element and map them to props\n    Array.from(element.attributes).forEach(attr => {\n      props[attr.name] = attr.value;\n    });\n\n    // Recursively parse child elements\n    const children = Array.from(element.childNodes)\n      .map(child => {\n        if (child.nodeType === 1) {\n          return this.parseElement(child as Element);\n        } else if (child.nodeType === 3 && child.textContent.trim() !== '') {\n          return child.textContent;\n        }\n        return null;\n      })\n      .filter(Boolean);\n\n    // Map XML tags to Stencil components\n    const componentMapping = {\n      'lido-container': (\n        <lido-container {...props} canplay={this.canplay} baseUrl={this.baseUrl}>\n          {children}\n        </lido-container>\n      ),\n      'lido-col': <lido-col {...props}>{children}</lido-col>,\n      'lido-trace': <lido-trace {...props}>{children}</lido-trace>,\n      'lido-image': <lido-image {...props}>{children}</lido-image>,\n      'lido-row': <lido-row {...props}>{children}</lido-row>,\n      'lido-text': <lido-text {...props}>{children}</lido-text>,\n      'lido-pos': <lido-pos {...props}>{children}</lido-pos>,\n      'lido-shape': <lido-shape {...props}>{children}</lido-shape>,\n      'lido-wrap': <lido-wrap {...props}>{children}</lido-wrap>,\n      'lido-random': <lido-random {...props}>{children}</lido-random>,\n    };\n\n    // If the tag is known, return the corresponding Stencil component, otherwise log a warning\n    if (componentMapping[tagName]) {\n      return componentMapping[tagName];\n    } else {\n      console.warn(`Unknown tag: ${tagName}`);\n      return null;\n    }\n  }\n\n  /**\n   * Parses the `lido-container` elements from the XML root element and stores them in the `containers` state.\n   *\n   * @param rootElement - The root element of the parsed XML document.\n   */\n  private parseContainers(rootElement: Element) {\n    const containers = [];\n    const containerElements = rootElement.querySelectorAll('lido-container');\n\n    // Parse each container and add it to the array\n    containerElements.forEach(container => {\n      const parsedElement = this.parseElement(container);\n      if (parsedElement) {\n        containers.push(parsedElement);\n      }\n    });\n\n    this.containers = containers;\n  }\n\n  /**\n   * Renders navigation dots for each container, indicating the progress of the user.\n   * Clicking on a dot allows the user to jump to a specific container.\n   */\n  private renderDots() {\n    return (\n      <div id=\"lido-dot-indicator\" class=\"lido-dot-container\">\n        {this.containers.map((_, index) => (\n          <span\n            class={`lido-dot ${index < this.currentContainerIndex ? 'completed' : index === this.currentContainerIndex ? 'current' : ''}`}\n            onClick={() => this.jumpToContainer(index)}\n          ></span>\n        ))}\n      </div>\n    );\n  }\n\n  /**\n   * Jumps to a specific container based on the index of the dot clicked.\n   *\n   * @param index - The index of the container to jump to.\n   */\n  private jumpToContainer(index: number) {\n    this.NextContainerKey(index);\n    // this.currentContainerIndex = index;\n    // this.containers = [...this.containers]; // Trigger re-render\n  }\n\n  render() {\n    if (!this.xmlData) {\n      // If no XML data is provided, prompt the user to provide it\n      return <div>Please provide XML data.</div>;\n    }\n\n    return (\n      <Host index={this.currentContainerIndex} totalIndex={this.containers.length}>\n        {/* Render the current container */}\n        <div key={this.currentContainerIndex}>{this.containers[this.currentContainerIndex]}</div>\n\n        {/* Render navigation dots below the container */}\n        {this.renderDots()}\n\n        {/* Show completion message if all containers have been displayed */}\n        {this.showCompletionMessage && <div class=\"lido-snackbar\">All containers have been displayed!</div>}\n      </Host>\n    );\n  }\n}\n",".lido-image {\n  user-select: none;\n  -webkit-user-drag: none;\n  object-fit: contain;\n  max-width: 100%;\n  max-height: 100%;\n  aspect-ratio: 1 / 1; /* Ensures the image retains a 1:1 aspect ratio\n  /* The image will scale to fit within its container, keeping the aspect ratio */\n}\n","import { Component, Prop, h, Element, Host, getAssetPath } from '@stencil/core';\nimport { convertUrlToRelative, initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoImage\n *\n * The `LidoImage` component displays an image element within a container. It is a versatile\n * component that allows dynamic sizing, positioning, visibility control, and event handling.\n * The component is designed to work in different types of environments, supporting custom\n * events such as touch, match, and entry events.\n */\n@Component({\n  tag: 'lido-image',\n  styleUrl: 'lido-image.css',\n  shadow: false,\n})\nexport class LidoImage {\n  /**\n   * The value associated with the image. Typically used for internal logic or identification.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the image component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the image component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the image within its container (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the image within its container (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the image relative to other elements.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color for the container of the image (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Defines the type of the image component, which can be used for conditional logic or styling purposes.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Controls the visibility of the image component. If `true`, the image is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier of an audio file associated with the image.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the image is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the image is entered (useful for animations or logic on entry).\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * The source URL of the image to be displayed.\n   */\n  @Prop() src: string;\n\n  /**\n   * Reference to the HTML element that represents this image component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle method that runs after the component has been loaded into the DOM.\n   * It initializes custom events based on the `type` of the image component.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles for the image, including dimensions, positioning, and visibility\n    const style = {\n      height: this.height,\n      width: this.width,\n      backgroundColor: this.bgColor,\n      top: this.y,\n      left: this.x,\n      zIndex: this.z,\n      display: this.visible ? 'flex' : 'none',\n      alignItems: 'center', // Vertically center the image\n      justifyContent: 'center', // Horizontally center the image\n    };\n\n    return (\n      <Host\n        type={this.type}\n        tabindex={this.tabIndex}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        value={this.value}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        <img class=\"lido-image\" src={convertUrlToRelative(this.src)} alt=\"\" style={style} />\n      </Host>\n    );\n  }\n}\n",".lido-pos {\n  top: var(--y, 0);\n  left: var(--x, 0);\n  height: var(--height, 100%);\n  width: var(--width, 100%);\n  background-color: var(--bgColor, #eeeeee);\n  display: flex;\n  justify-content: space-around;\n  flex-direction: column;\n  position: fixed;\n  \n}\n\n.lido-pos > * {\n  position: absolute;\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoPos\n *\n * The `LidoPos` component is used to position a block-level element with dynamic styling and event handling.\n * It supports positioning with `x` and `y` coordinates, sizing with `height` and `width`, and custom\n * events for interaction such as touch, match, and entry events.\n */\n@Component({\n  tag: 'lido-pos',\n  styleUrl: 'lido-pos.css',\n  shadow: false,\n})\nexport class LidoPos {\n  /**\n   * Unique identifier for the positional element.\n   */\n  @Prop() id: string;\n\n  /**\n   * Value assigned to the component, often used for internal logic or data tracking.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the component (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the component (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the element relative to others.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the component (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * The type of the component, used for conditional logic or specific styles.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index to support keyboard navigation within the component.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Visibility flag to control whether the element is displayed (`true`) or hidden (`false`).\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier for an audio file associated with the component.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the component is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the component is entered, often used to trigger animations or custom logic.\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Reference to the HTML element that represents this `lido-pos` component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle hook that is called after the component has been rendered in the DOM.\n   * It initializes custom events based on the `type` of the component.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles to position and size the component\n    const style = {\n      height: this.height,\n      width: this.width,\n      backgroundColor: this.bgColor,\n      top: this.y,\n      left: this.x,\n      zIndex: this.z,\n      display: this.visible ? 'block' : 'none', // Toggle visibility\n    };\n\n    return (\n      <Host\n        id={this.id}\n        class=\"lido-pos\"\n        type={this.type}\n        tabindex={this.tabIndex}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        value={this.value}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        {/* Slot for child elements */}\n        <slot />\n      </Host>\n    );\n  }\n}\n",".lido-random {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  position: absolute; /* Container is now relative */\n}\n\n.lido-random > * {\n  position: absolute;\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\n\n/**\n * @component LidoRandom\n *\n * The `LidoRandom` component randomly positions its child elements within its container.\n * This component can be used when a random layout of elements is required. It allows\n * full customization via props such as dimensions, positioning, visibility, and event handling.\n */\n@Component({\n  tag: 'lido-random',\n  styleUrl: 'lido-random.css',\n  shadow: false,\n})\nexport class LidoRandom {\n  /**\n   * Unique identifier for the random container.\n   */\n  @Prop() id: string;\n\n  /**\n   * Value associated with the component, often used for internal logic.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the container (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the container (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the container (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the container (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the container relative to other elements.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the container (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * The type of the component, used for conditional logic or specific styling.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Controls the visibility of the container. If `true`, the container is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier for an audio file associated with the component.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the component is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the component is entered (useful for animations or logic on entry).\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Reference to the HTML element representing this component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle hook that runs after the component is rendered in the DOM.\n   * It randomly positions all child elements within the container using CSS `top` and `left` percentages.\n   */\n  componentDidLoad() {\n    // Select all direct child elements of the component\n    const slotElements = this.el.querySelectorAll('.lido-random > *');\n\n    // Iterate over each child and apply random positions\n    slotElements.forEach((child: HTMLElement) => {\n      const randomTop = Math.random() * 100; // Random value between 0 and 100 for vertical position\n      const randomLeft = Math.random() * 100; // Random value between 0 and 100 for horizontal position\n\n      child.style.top = `${randomTop}%`;\n      child.style.left = `${randomLeft}%`;\n    });\n  }\n\n  render() {\n    // Inline styles for the container, including dimensions, positioning, and visibility\n    const style = {\n      height: this.height,\n      width: this.width,\n      top: this.y,\n      left: this.x,\n      display: this.visible ? 'block' : 'none', // Toggle visibility\n      zIndex: this.z,\n      backgroundColor: this.bgColor,\n    };\n\n    return (\n      <Host\n        class=\"lido-random\"\n        type={this.type}\n        tabindex={this.tabIndex}\n        value={this.value}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        {/* Slot to render child elements that will be randomly positioned */}\n        <slot />\n      </Host>\n    );\n  }\n}\n","import { Component, h, State, Prop, getAssetPath } from '@stencil/core';\n\n/**\n * @component LidoRoot\n *\n * The `LidoRoot` component is the main application entry point. It loads an external XML data file\n * from a specified URL or asset path and passes it down to the `lido-home` component for rendering.\n * The XML path can be configured via a prop.\n */\n@Component({\n  tag: 'lido-root',\n  shadow: false,\n  assetsDirs: ['assets'], // Specifies the directory for static assets\n})\nexport class LidoRoot {\n  /**\n   * Prop to hold the XML file path or URL. This can be a relative path or an external URL.\n   */\n  @Prop() xmlPath: string;\n\n  /**\n   * Initial index of the container being displayed.\n   */\n  @Prop() initialIndex: number = 0;\n\n  /**\n   * Boolean that controls the playability of the game.\n   */\n  @Prop() canplay: boolean = true;\n\n  /**\n   * Base URL for the containers.\n   */\n  @Prop() baseUrl: string = '';\n\n  /**\n   * State variable to hold the XML data fetched from the specified path or URL.\n   */\n  @State() xmlData: string;\n\n  /**\n   * Lifecycle method that runs before the component is loaded.\n   * It fetches the XML data from the specified path or URL and sets it to the component's state.\n   */\n  async componentWillLoad() {\n    // Validate the xmlPath prop\n    // if (!this.xmlPath) {\n    //   console.error('XML path is not provided.');\n    //   return;\n    // }\n    const xmlPath = this.xmlPath ?? this.baseUrl + '/index.xml';\n    console.log('ðŸš€ ~ LidoRoot ~ componentWillLoad ~ this.baseUrl:', this.baseUrl);\n    console.log('ðŸš€ ~ LidoRoot ~ componentWillLoad ~ this.xmlPath:', this.xmlPath);\n    console.log('ðŸš€ ~ LidoRoot ~ componentWillLoad ~ xmlPath:', xmlPath);\n    // Fetch the XML data\n    try {\n      const resolvedPath = xmlPath.startsWith('http')\n        ? xmlPath // Use the provided URL if it's an HTTP/HTTPS link\n        : getAssetPath(xmlPath); // Otherwise, resolve it as an asset path\n\n      const response = await fetch(resolvedPath);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch XML data: ${response.statusText}`);\n      }\n      const data = await response.text();\n\n      // Store the XML data in the component's state\n      this.xmlData = data;\n    } catch (error) {\n      console.error('Error fetching XML data:', error);\n      this.xmlData = null;\n    }\n  }\n\n  render() {\n    // Show a loading message until the XML data is fetched\n    if (this.xmlData === undefined) {\n      return <div>Loading...</div>;\n    }\n\n    // Show an error message if the XML data could not be fetched\n    if (this.xmlData === null) {\n      return <div>Error loading XML data. Please check the path or URL.</div>;\n    }\n\n    // Once the XML data is loaded, pass it to the `lido-home` component\n    return <lido-home initialIndex={this.initialIndex} canplay={this.canplay} xmlData={this.xmlData} baseUrl={this.baseUrl}></lido-home>;\n  }\n}\n",".lido-row {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  /* position: absolute; */\n}\n\n.lido-row > * {\n  /* position: relative; */\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoRow\n *\n * The `LidoRow` component is used to create a flexible row element that can contain other elements.\n * It supports dynamic positioning, sizing, visibility control, and custom events for interaction.\n */\n@Component({\n  tag: 'lido-row',\n  styleUrl: 'lido-row.css',\n  shadow: false,\n})\nexport class LidoRow {\n  /**\n   * Value associated with the row, typically used for internal logic or data.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the row (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the row (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the row (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the row (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the row relative to other elements.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the row (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Defines the type of the row, used for conditional logic or specific styling.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Controls the visibility of the row. If `true`, the row is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier of an audio file associated with the row.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the row is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the row is entered, often used for triggering animations or custom logic.\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Reference to the HTML element representing this `lido-row` component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle hook that runs after the component is loaded into the DOM.\n   * It initializes custom events based on the `type` of the row component.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles to position and size the row component\n    const style = {\n      height: this.height,\n      width: this.width,\n      top: this.y,\n      left: this.x,\n      display: this.visible ? 'flex' : 'none', // Flexbox for row layout\n      zIndex: this.z,\n      backgroundColor: this.bgColor, // Apply background color if provided\n    };\n\n    return (\n      <Host\n        class=\"lido-row\"\n        type={this.type}\n        tabindex={this.tabIndex}\n        value={this.value}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        {/* Slot for child elements */}\n        <slot />\n      </Host>\n    );\n  }\n}\n",".lido-shape {\n  position: absolute;\n  top: var(--y);\n  left: var(--x);\n  display: var(--display);\n  z-index: var(--z);\n}\n\n.lido-rectangle {\n  border-radius: 0;\n}\n\n.lido-circle {\n  width: var(--width); /* Ensures width is always used for both dimensions */\n  height: var(--width); /* Make height equal to width for a perfect circle */\n  border-radius: 50%; /* 50% border-radius for a perfect circle */\n  background-color: var(--bgColor);\n}\n\n.lido-ellipse {\n  width: var(--width);\n  height: var(--height);\n  border-radius: 50%; /* Create an ellipse shape */\n  background-color: var(--bgColor);\n}\n\n/* other shapes */\n\n.lido-triangle {\n  width: var(--triangleWidth);\n  height: var(--triangleHeight);\n  background-color: var(--bgColor);\n  clip-path: polygon(50% 0%, 100% 100%, 0% 100%);\n}\n\n.lido-rightTriangle {\n  width: var(--triangleWidth);\n  height: var(--triangleHeight);\n  background-color: var(--bgColor);\n  clip-path: polygon(100% 0%, 100% 100%, 0% 100%);\n}\n\n.lido-leftTriangle {\n  width: var(--triangleWidth);\n  height: var(--triangleHeight);\n  background-color: var(--triangleBgColor);\n  clip-path: polygon(0% 0%, 100% 100%, 0% 100%);\n}\n\n.lido-parallelogram {\n  width: var(--paralleWidth);\n  height: var(--paralleHeight);\n  transform: skew(20deg);\n}\n\n.lido-star {\n  width: var(--starWidth);\n  height: var(--starHeight);\n  background-color: var(--starBgColor);\n  clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);\n}\n\n.lido-pentagon {\n  width: var(--pentagonWidth);\n  height: var(--pentagonHeight);\n  background-color: var(--pentagonBgColor);\n  clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);\n}\n\n.lido-heptagon {\n  width: var(--heptagonWidth);\n  height: var(--heptagonHeight);\n  background-color: var(--heptagonBgColor);\n  clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);\n}\n\n.lido-octagon {\n  width: var(--octagonWidth);\n  height: var(--octagonHeight);\n  background-color: var(--octagonBgColor);\n  clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);\n}\n\n.lido-rhombus {\n  width: var(--rhombusWidth);\n  height: var(--rhombusHeight);\n  background-color: var(--rhombusBgColor);\n  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);\n}\n\n.lido-heart {\n  height: var(--heartHeight);\n  width: var(--heartWidth);\n  border-image: radial-gradient(var(--heartBgColor) 69%, #0000 70%) 84.5%/50%;\n  clip-path: polygon(-41% 0, 50% 91%, 141% 0);\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoShape\n *\n * The `LidoShape` component is used to display various types of shapes like rectangles, circles, or polygons.\n * The shape's appearance is dynamically controlled by props such as dimensions, position, visibility, and the type of shape.\n * Additionally, it supports custom events for interaction like touch, match, and entry.\n */\n@Component({\n  tag: 'lido-shape',\n  styleUrl: 'lido-shape.css',\n  shadow: false,\n})\nexport class LidoShape {\n  /**\n   * Unique identifier for the shape element.\n   */\n  @Prop() id: string;\n\n  /**\n   * Value associated with the shape, typically used for internal logic or tracking.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the shape (CSS value, e.g., '100px', '50%').\n   * This is ignored for polygons.\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the shape (CSS value, e.g., '100px', '50%').\n   * This is ignored for polygons.\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the shape (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the shape (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the shape relative to other elements.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the shape (CSS color value, e.g., '#FFFFFF', 'blue').\n   * This is ignored for polygons.\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Defines the type of the shape, which can be used for conditional logic or specific styling.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Type of shape to render (e.g., 'circle', 'rectangle', 'polygon').\n   */\n  @Prop() shapeType: string;\n\n  /**\n   * Controls the visibility of the shape. If `true`, the shape is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier for an audio file associated with the shape.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the shape is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the shape is entered (useful for animations or logic on entry).\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Reference to the HTML element representing this `lido-shape` component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle hook that runs after the component is loaded into the DOM.\n   * It initializes custom events based on the `type` of the shape component.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles to position and size the shape component\n    const style = {\n      height: this.shapeType !== 'polygon' ? this.height : undefined, // Set height unless it's a polygon\n      width: this.shapeType !== 'polygon' ? this.width : undefined, // Set width unless it's a polygon\n      top: this.y,\n      left: this.x,\n      display: this.visible ? 'block' : 'none', // Toggle visibility\n      zIndex: this.z,\n      backgroundColor: this.shapeType !== 'polygon' ? this.bgColor : 'transparent', // Apply background only if not a polygon\n    };\n\n    return (\n      <Host\n        class={`lido-shape ${this.shapeType}`} // Apply shape-specific class\n        value={this.value}\n        type={this.type}\n        tabindex={this.tabIndex}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        {/* Slot for any child elements */}\n      </Host>\n    );\n  }\n}\n",".lido-text {\n  background-color: #fff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  transition: background-color 0.3s ease;\n  user-select: none;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  border-radius: 8px;\n  color: #333;\n  cursor: pointer;\n}\n\n.lido-text:hover {\n  background-color: #f0f0f0;\n}\n","import { Component, Prop, h, Element, Host } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoText\n *\n * The `LidoText` component is used to display text with customizable styling.\n * It allows you to set the font, size, color, and background color, along with\n * positioning and visibility control. The component supports custom events like touch, match, and entry.\n */\n@Component({\n  tag: 'lido-text',\n  styleUrl: 'lido-text.css',\n  shadow: false,\n})\nexport class LidoText {\n  /**\n   * Unique identifier for the text element.\n   */\n  @Prop() id: string;\n\n  /**\n   * Value associated with the text element, typically used for internal logic or tracking.\n   */\n  @Prop() value: string;\n\n  /**\n   * The string of text to be displayed in the component.\n   */\n  @Prop() string: string;\n\n  /**\n   * Font family for the text (CSS value, e.g., 'Arial', 'Times New Roman').\n   */\n  @Prop() font: string;\n\n  /**\n   * Font size for the text (CSS value, e.g., '16px', '1.5em').\n   */\n  @Prop() fontSize: string;\n\n  /**\n   * Font color for the text (CSS color value, e.g., '#000000', 'red').\n   */\n  @Prop() fontColor: string;\n\n  /**\n   * When set to `true`, the text will highlight while being spoken, typically used for accessibility.\n   */\n  @Prop() highlightWhileSpeaking: boolean;\n\n  /**\n   * Height of the text component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * Width of the text component (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the text component (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the text component (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the text component relative to other elements.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the text component (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Defines the type of the component, which can be used for conditional logic or specific styling.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Controls the visibility of the text component. If `true`, the text is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier for an audio file associated with the text component.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the text component is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the text component is entered (useful for animations or logic on entry).\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Determines whether only a single draggable element is allowed to be dropped.\n   * If set to 'true', only one draggable element can be dropped in the drop zone.\n   * If set to 'false', multiple draggable elements are allowed.\n   */\n  @Prop() isAllowOnlyOneDrop: string;\n\n  /**\n   * Reference to the HTML element representing this `lido-text` component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle hook that runs after the component is rendered in the DOM.\n   * It initializes custom events based on the `type` of the text component.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles to customize the appearance and positioning of the text component\n    const style = {\n      height: this.height,\n      width: this.width,\n      backgroundColor: this.bgColor,\n      top: this.y,\n      left: this.x,\n      zIndex: this.z,\n      fontSize: this.fontSize,\n      fontFamily: this.font,\n      color: this.fontColor,\n      display: this.visible ? 'flex' : 'none', // Show or hide based on visibility prop\n    };\n\n    return (\n      <Host\n        class=\"lido-text\"\n        value={this.value}\n        type={this.type}\n        tabindex={this.tabIndex}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n        id={this.id}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        isAllowOnlyOneDrop={this.isAllowOnlyOneDrop}\n      >\n        {this.string}\n      </Host>\n    );\n  }\n}\n",":host {\n  display: block;\n  position: relative;\n}\n\n#lido-svgContainer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 50px; /* Leave space for controls */\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  overflow: hidden;\n}\n\nsvg {\n  width: 100%;\n  height: 100%;\n  max-height: calc(100vh - 50px);\n  /* border: 1px solid black; */\n  touch-action: none;\n}\n\n#lido-draggableCircle {\n  cursor: pointer;\n  fill: red;\n  transition: fill 0.2s, r 0.2s;\n}\n\n.lido-blindTracing {\n  stroke: none !important;\n}\n\n.lido-blindFreeTrace {\n  stroke: none !important;\n}\n\n.lido-hovered {\n  cursor: grab;\n  fill: darkred;\n}\n\n#lido-controls {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  display: flex;\n  justify-content: space-between;\n  padding: 10px;\n  background-color: #f0f0f0;\n  border-top: 1px solid #ccc;\n}\n\nbutton {\n  padding: 10px;\n  font-size: 16px;\n}\n\n@media (max-width: 600px) {\n  button {\n    padding: 8px;\n    font-size: 14px;\n  }\n}\n.lido-trace-path-green {\n  stroke: green !important;\n}\n\n","import { Component, Prop, h, Host, State } from '@stencil/core';\nimport { triggerNextContainer } from '../../utils/utils';\nimport { TraceMode } from '../../utils/constants';\n\n// Enum for different tracing modes\n\n@Component({\n  tag: 'lido-trace',\n  styleUrl: 'lido-trace.css',\n  shadow: false,\n  assetsDirs: ['svg'],\n})\nexport class LidoTrace {\n  /**\n   * Various configuration properties for `lido-trace`\n   */\n  /**\n   * Unique identifier for this `lido-trace` component instance.\n   */\n  @Prop() id: string;\n\n  /**\n   * Source URL or path for the SVG file used in this component.\n   */\n  @Prop() svgSource: string;\n\n  /**\n   * A custom string value associated with the component for additional data or identification.\n   */\n  @Prop() value: string;\n\n  /**\n   * Specifies the height of the component container, accepts any valid CSS height value (e.g., `\"100px\"`, `\"50%\"`).\n   */\n  @Prop() height: string;\n\n  /**\n   * Specifies the width of the component container, accepts any valid CSS width value (e.g., `\"100px\"`, `\"50%\"`).\n   */\n  @Prop() width: string;\n\n  /**\n   * Defines the x-coordinate position (left offset) of the component container, using any valid CSS `left` value (e.g., `\"10px\"`, `\"5%\"`).\n   */\n  @Prop() x: string;\n\n  /**\n   * Defines the y-coordinate position (top offset) of the component container, using any valid CSS `top` value (e.g., `\"10px\"`, `\"5%\"`).\n   */\n  @Prop() y: string;\n\n  /**\n   * Sets the z-index of the component, controlling its stacking order on the page.\n   */\n  @Prop() z: string;\n\n  /**\n   * Accessible label for screen readers, providing a textual description of the component's purpose.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * Controls visibility for assistive technologies. If `\"true\"`, the component is hidden from screen readers.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * Sets the tab order of the component within the page, enabling keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Mode for the tracing interaction, defining how users interact with the SVG paths.\n   * Options may include `\"noFlow\"`, `\"showFlow\"`, `\"freeTrace\"`, `\"blindTracing\"`, and `\"blindFreeTrace\"`.\n   */\n  @Prop() mode: string;\n\n  //   @Element() el!: HTMLElement;\n\n  @State() fileIndex: number = -1;\n  @State() isDragging: boolean = false;\n  @State() activePointerId: number | null = null;\n\n  // MODES = ['noFlow', 'showFlow', 'freeTrace', 'blindTracing', 'blindFreeTrace'];\n\n  // Handle the pointermove event with optimizations\n  // Update the path trace as the red circle moves\n  async initializeSVG() {\n    let state = {\n      fileIndex: -1,\n      currentPathIndex: 0,\n      lastLength: 0,\n      totalPathLength: 0,\n      isDragging: false,\n      circle: null as SVGCircleElement | null,\n      paths: [] as SVGGeometryElement[],\n      svg: null as SVGSVGElement | null,\n      proximityThreshold: 100, // General proximity threshold\n      freeTraceProximityThreshold: 50, // Reduced proximity threshold for free trace\n      rafId: null as number | null,\n      pointerMoveEvent: null as PointerEvent | null,\n      activePointerId: null as number | null,\n      mode: this.mode,\n      flowMarkers: [] as SVGPolygonElement[],\n      freeTraceLines: [] as SVGPathElement[],\n    };\n\n    await this.loadAnotherSVG(state, true); // Load the first SVG\n  }\n\n  componentWillLoad() {\n    this.initializeSVG();\n  }\n  // Fetch the SVG file asynchronously\n  async fetchSVG(url: string): Promise<string> {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch SVG (${url}): ${response.statusText}`);\n    }\n    return await response.text();\n  }\n\n  // to calculate the bounding box of all paths\n  calculateBoundingBox(paths: SVGGeometryElement[], padding = 22) {\n    let minX = Infinity,\n      minY = Infinity,\n      maxX = -Infinity,\n      maxY = -Infinity;\n    paths.forEach(path => {\n      const length = path.getTotalLength();\n      const numPoints = 100; // Number of points to sample along the path\n      for (let i = 0; i <= numPoints; i++) {\n        const point = path.getPointAtLength((i / numPoints) * length);\n        if (point.x < minX) minX = point.x;\n        if (point.y < minY) minY = point.y;\n        if (point.x > maxX) maxX = point.x;\n        if (point.y > maxY) maxY = point.y;\n      }\n    });\n    // Apply padding\n    minX -= padding;\n    minY -= padding;\n    maxX += padding;\n    maxY += padding;\n    return { minX, minY, maxX, maxY };\n  }\n\n  // Insert the fetched SVG into the container and adjust viewBox\n  insertSVG(svgText: string) {\n    const svgContainer = document.getElementById('svgContainer') as HTMLElement;\n    svgContainer.innerHTML = svgText;\n\n    // After inserting, get the SVG element\n    const svgElement = svgContainer.querySelector('svg') as SVGSVGElement;\n\n    // Remove the width and height attributes from the SVG element\n    svgElement.removeAttribute('width');\n    svgElement.removeAttribute('height');\n\n    // Get all paths\n    const paths = svgElement.querySelectorAll('path, line') as NodeListOf<SVGGeometryElement>;\n\n    // Calculate bounding box\n    const bbox = this.calculateBoundingBox(Array.from(paths));\n\n    // Set the viewBox to the bounding box\n    const viewBoxWidth = bbox.maxX - bbox.minX;\n    const viewBoxHeight = bbox.maxY - bbox.minY;\n    svgElement.setAttribute('viewBox', `${bbox.minX} ${bbox.minY} ${viewBoxWidth} ${viewBoxHeight}`);\n  }\n\n  // Retrieve the SVG element from the container\n  getSVGElement() {\n    const svgContainer = document.getElementById('svgContainer') as HTMLElement;\n    return svgContainer.querySelector('svg');\n  }\n\n  // Get all path and line elements from the SVG\n  getPaths(svg: SVGSVGElement) {\n    return Array.from(svg.querySelectorAll('path, line'));\n  }\n\n  // Create flow markers along the path to guide the user\n  createFlowMarkersForPath(path: SVGGeometryElement, markerCount = 10) {\n    const totalLength = path.getTotalLength();\n    const interval = totalLength / (markerCount + 1); // Space markers evenly\n    const markers: SVGPolygonElement[] = [];\n\n    for (let i = 1; i <= markerCount; i++) {\n      const point = path.getPointAtLength(i * interval);\n      const nextPoint = path.getPointAtLength((i + 0.5) * interval); // Slightly ahead point for direction\n\n      // Create an arrow marker\n      const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);\n      const arrowMarker = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n      arrowMarker.setAttribute('points', '-5,-5 0,0 -5,5');\n      arrowMarker.setAttribute('fill', 'blue');\n      arrowMarker.setAttribute('transform', `translate(${point.x},${point.y}) rotate(${(angle * 180) / Math.PI})`);\n      arrowMarker.setAttribute('class', 'lido-flow-indicator');\n      markers.push(arrowMarker);\n      path.parentNode?.appendChild(arrowMarker); // Append to the same SVG container\n    }\n    return markers;\n  }\n\n  // Show or hide flow indicators based on mode\n  updateFlowIndicators(state: any) {\n    const indicators = state.svg.querySelectorAll('.lido-flow-indicator');\n    indicators.forEach(indicator => {\n      if (state.mode === TraceMode.NoFlow) {\n        (indicator as HTMLElement).style.display = 'none';\n      } else if (state.mode === TraceMode.ShowFlow) {\n        (indicator as HTMLElement).style.display = 'block';\n      }\n    });\n  }\n\n  // Create a new path element for the drawing effect\n  setupDrawingPath(state: any) {\n    state.paths.forEach((path: any, index: number) => {\n      const pathLength = path.getTotalLength();\n\n      // Create green path for tracing effect\n      const greenPath = path.cloneNode() as SVGPathElement;\n      greenPath.setAttribute('stroke', 'green');\n      greenPath.setAttribute('stroke-width', '13');\n      greenPath.setAttribute('stroke-dasharray', pathLength.toString());\n      greenPath.setAttribute('stroke-dashoffset', pathLength.toString()); // Hidden initially\n      path.parentNode.appendChild(greenPath, path);\n\n      path.setAttribute('class', 'lido-trace-path'); // Add class for easier reference\n      greenPath.setAttribute('class', 'lido-trace-path-green'); // Add class for easier reference\n\n      (path as any).greenPath = greenPath;\n      path.classList.add(state.mode);\n\n      // Conditionally hide or show the black path based on blind tracing mode\n      if (state.mode === TraceMode.BlindTracing || state.mode === TraceMode.BlindFreeTrace) {\n        // In blind tracing or blind free trace mode, hide the black path\n        path.setAttribute('stroke', 'none');\n      } else {\n        // In other modes, show the black path\n        path.setAttribute('stroke', '#000');\n        path.setAttribute('stroke-width', '10');\n        path.setAttribute('fill', 'none');\n        path.setAttribute('stroke-dasharray', pathLength.toString());\n        path.setAttribute('stroke-dashoffset', '0'); // Fully visible initially\n      }\n\n      // Only create flow markers for the current path in normal modes\n      if (index === state.currentPathIndex && state.mode === TraceMode.ShowFlow) {\n        state.flowMarkers = this.createFlowMarkersForPath(path);\n      }\n    });\n\n    state.totalPathLength = state.paths[state.currentPathIndex].getTotalLength();\n  }\n\n  // Set up the draggable circle at the start of the first path\n  setupDraggableCircle(state: any) {\n    const firstPathStart = state.paths[0].getPointAtLength(0);\n    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    circle.setAttribute('id', 'lido-draggableCircle');\n    circle.setAttribute('cx', firstPathStart.x.toString());\n    circle.setAttribute('cy', firstPathStart.y.toString());\n    circle.setAttribute('r', '20'); // Radius of the draggable circle\n    circle.setAttribute('fill', 'red');\n    state.svg?.appendChild(circle);\n    state.circle = circle;\n  }\n\n  // Add necessary event listeners using Pointer Events\n  addEventListeners(state: any) {\n    // Ensure the circle exists before adding events\n    if (!state.circle || !state.paths || state.paths.length === 0) return;\n\n    // Handle pointerdown on the circle to start dragging\n    state.circle.addEventListener('pointerdown', (evt: PointerEvent) => {\n      evt.preventDefault(); // Prevent default actions like text selection\n      const pointerPos = this.getPointerPosition(evt, state.svg!);\n      const circlePos = {\n        x: parseFloat(state.circle.getAttribute('cx')!),\n        y: parseFloat(state.circle.getAttribute('cy')!),\n      };\n      const distance = this.getDistanceSquared(pointerPos, circlePos);\n      if (distance <= state.proximityThreshold * state.proximityThreshold) {\n        state.isDragging = true;\n        state.activePointerId = evt.pointerId;\n        // Capture the pointer to continue receiving events even if it leaves the element\n        state.circle.setPointerCapture(evt.pointerId);\n      }\n    });\n\n    // Handle pointermove on the SVG to update the circle position\n    state.svg?.addEventListener('pointermove', (evt: PointerEvent) => {\n      if (!state.isDragging || evt.pointerId !== state.activePointerId) return;\n\n      state.pointerMoveEvent = evt;\n      if (!state.rafId) {\n        state.rafId = requestAnimationFrame(() => {\n          this.handlePointerMove(state);\n          state.rafId = null;\n        });\n      }\n    });\n\n    // Handle pointerup and pointercancel on the SVG to stop dragging\n    state.svg?.addEventListener('pointerup', (evt: PointerEvent) => {\n      if (evt.pointerId === state.activePointerId) {\n        state.isDragging = false;\n        state.activePointerId = null;\n      }\n    });\n\n    state.svg?.addEventListener('pointercancel', (evt: PointerEvent) => {\n      if (evt.pointerId === state.activePointerId) {\n        state.isDragging = false;\n        state.activePointerId = null;\n      }\n    });\n\n    // Optional: Prevent context menu on long press\n    state.svg?.addEventListener('contextmenu', (evt: MouseEvent) => {\n      evt.preventDefault();\n    });\n  }\n\n  // Modified handlePointerMove function\n  handlePointerMove(state: any) {\n    if (!state.isDragging) return;\n    if (!state.circle || !state.paths || state.paths.length === 0) return;\n\n    const evt = state.pointerMoveEvent as PointerEvent;\n    const pointerPos = this.getPointerPosition(evt, state.svg!);\n    const circlePos = {\n      x: parseFloat(state.circle.getAttribute('cx')!),\n      y: parseFloat(state.circle.getAttribute('cy')!),\n    };\n\n    const currentPath = state.paths[state.currentPathIndex];\n    if (!currentPath) {\n      console.error('No valid path found at the current index');\n      return;\n    }\n\n    // Use a reduced proximity threshold for free trace mode\n    let proximitySquared;\n    if (state.mode === TraceMode.FreeTrace || state.mode === TraceMode.BlindFreeTrace) {\n      proximitySquared = state.freeTraceProximityThreshold * state.freeTraceProximityThreshold;\n    } else {\n      proximitySquared = state.proximityThreshold * state.proximityThreshold;\n    }\n\n    // Calculate the distance between the pointer and the draggable circle\n    const distanceSquared = this.getDistanceSquared(pointerPos, circlePos);\n\n    // If the pointer is outside the proximity threshold, do not proceed with drawing or moving\n    if (distanceSquared > proximitySquared) {\n      return; // Skip any further actions\n    }\n\n    const closestPoint = this.getClosestPointOnPath(currentPath, pointerPos);\n\n    // Ensure drawing happens only within proximity threshold\n    const distanceToPathSquared = this.getDistanceSquared(pointerPos, closestPoint);\n    if (distanceToPathSquared > proximitySquared) {\n      return; // Skip drawing if too far from the path\n    }\n\n    // For free trace mode and blind free trace mode, allow free drawing only if within the reduced proximity threshold\n    if (state.mode === TraceMode.FreeTrace || state.mode === TraceMode.BlindFreeTrace) {\n      // Initialize the currentFreePath array if it's not created\n      if (!state.currentFreePath) {\n        state.currentFreePath = [];\n      }\n\n      // Create a new path element if it's the first trace for the current path index\n      if (!state.currentFreePath[state.currentPathIndex]) {\n        const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        newPath.setAttribute('stroke', 'green');\n        newPath.setAttribute('stroke-width', '8');\n        newPath.setAttribute('fill', 'none');\n\n        // Start the new path at the current pointer position\n        newPath.setAttribute('d', `M${pointerPos.x},${pointerPos.y}`);\n        state.svg?.appendChild(newPath);\n        state.currentFreePath[state.currentPathIndex] = newPath;\n\n        // Reset lastPointerPos for the new path\n        state.lastPointerPos = pointerPos;\n      }\n\n      // Get the previous position to draw a smooth curve\n      const previousPos = state.lastPointerPos || pointerPos;\n\n      // Create a quadratic curve from the previous point to the current point\n      const newPathData = state.currentFreePath[state.currentPathIndex].getAttribute('d');\n      const midPointX = (previousPos.x + pointerPos.x) / 2;\n      const midPointY = (previousPos.y + pointerPos.y) / 2;\n      const updatedPathData = `${newPathData} Q ${previousPos.x},${previousPos.y} ${midPointX},${midPointY}`;\n\n      // Update the path's 'd' attribute with the new curve\n      state.currentFreePath[state.currentPathIndex].setAttribute('d', updatedPathData);\n\n      // Move the draggable circle with the freehand trace\n      state.circle.setAttribute('cx', pointerPos.x.toString());\n      state.circle.setAttribute('cy', pointerPos.y.toString());\n\n      // Make sure the red dot (circle) is always on top\n      state.svg?.appendChild(state.circle); // This moves the circle to the last child, making it the topmost\n\n      // Update the last pointer position\n      state.lastPointerPos = pointerPos;\n\n      const currentPathLength = currentPath.getTotalLength();\n      const distanceToEnd = currentPathLength - closestPoint.length;\n\n      // If close to the end of the path, move to the next path\n      if (distanceToEnd < 5) {\n        this.moveToNextPath(state);\n        state.currentFreePath[state.currentPathIndex] = null; // Reset free path for next path\n      }\n\n      return; // Exit early since we're in free trace or blind free trace mode\n    }\n\n    // In normal modes, allow movement and drawing only within the general proximity threshold\n    if (state.isDragging && closestPoint.length >= state.lastLength) {\n      state.lastLength = closestPoint.length;\n      state.circle.setAttribute('cx', closestPoint.x.toString());\n      state.circle.setAttribute('cy', closestPoint.y.toString());\n\n      // Make sure the red dot (circle) is always on top\n      state.svg?.appendChild(state.circle); // This moves the circle to the last child, making it the topmost\n\n      currentPath.greenPath?.setAttribute('stroke-dashoffset', (state.totalPathLength - state.lastLength).toString());\n    }\n\n    // Check if the current path is completed\n    if (state.totalPathLength - 1 - state.lastLength < 5 && state.currentPathIndex < state.paths.length - 1) {\n      this.moveToNextPath(state);\n    } else if (state.totalPathLength - 1 - state.lastLength < 5 && state.currentPathIndex === state.paths.length - 1) {\n      //   this.loadAnotherSVG(state, true);\n      triggerNextContainer();\n    }\n  }\n\n  // Get the pointer position relative to the SVG\n  getPointerPosition(evt: PointerEvent, svg: SVGSVGElement) {\n    const svgPoint = svg.createSVGPoint();\n    svgPoint.x = evt.clientX;\n    svgPoint.y = evt.clientY;\n    const ctm = svg.getScreenCTM()?.inverse();\n    return ctm ? svgPoint.matrixTransform(ctm) : { x: evt.clientX, y: evt.clientY };\n  }\n\n  // Calculate the squared Euclidean distance between two points\n  getDistanceSquared(p1: { x: number; y: number }, p2: { x: number; y: number }) {\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n  }\n\n  // Find the closest point on the given path to the specified point using two-pass sampling\n  getClosestPointOnPath(pathNode: SVGGeometryElement, point: { x: number; y: number }) {\n    const pathLength = pathNode.getTotalLength();\n    let closestPoint = { x: 0, y: 0, length: 0 };\n    let minDistanceSquared = Infinity;\n\n    // First pass: coarse sampling\n    const coarseStep = 20; // Increased step for better performance\n    let coarseClosestPoint = { x: 0, y: 0, length: 0 };\n    let coarseMinDistanceSquared = Infinity;\n\n    for (let i = 0; i <= pathLength; i += coarseStep) {\n      const pointOnPath = pathNode.getPointAtLength(i);\n      const distanceSquared = this.getDistanceSquared(point, pointOnPath);\n\n      if (distanceSquared < coarseMinDistanceSquared) {\n        coarseMinDistanceSquared = distanceSquared;\n        coarseClosestPoint = {\n          x: pointOnPath.x,\n          y: pointOnPath.y,\n          length: i,\n        };\n      }\n    }\n\n    // Second pass: fine sampling around coarseClosestPoint\n    const fineStep = 2; // Increased step to reduce computations\n    const searchStart = Math.max(coarseClosestPoint.length - coarseStep, 0);\n    const searchEnd = Math.min(coarseClosestPoint.length + coarseStep, pathLength);\n\n    for (let i = searchStart; i <= searchEnd; i += fineStep) {\n      const pointOnPath = pathNode.getPointAtLength(i);\n      const distanceSquared = this.getDistanceSquared(point, pointOnPath);\n\n      if (distanceSquared < minDistanceSquared) {\n        minDistanceSquared = distanceSquared;\n        closestPoint = { x: pointOnPath.x, y: pointOnPath.y, length: i };\n      }\n    }\n\n    return closestPoint;\n  }\n\n  // Load the next or previous SVG based on the isNext flag\n  async loadAnotherSVG(state: any, isNext: boolean) {\n    state.isDragging = false;\n\n    // Update fileIndex based on whether isNext is true or false\n    // if (isNext) {\n    //   state.fileIndex++;\n    //   if (state.fileIndex >= this.svgFiles.length) {\n    //     state.fileIndex = this.svgFiles.length - 1; // Stay at the last file\n    //     return;\n    //   }\n    // } else {\n    //   state.fileIndex--;\n    //   if (state.fileIndex < 0) {\n    //     state.fileIndex = 0; // Stay at the first file\n    //     return;\n    //   }\n    // }\n\n    try {\n      if (state.svg) {\n        this.cleanupPreviousSVG(state);\n      }\n\n      //   const svgText = await this.fetchSVG(this.svgSource ?? this.svgFiles[state.fileIndex]);\n      const svgText = await this.fetchSVG(this.svgSource);\n\n      this.insertSVG(svgText);\n\n      state.svg = this.getSVGElement();\n      state.paths = this.getPaths(state.svg);\n\n      this.setupDrawingPath(state);\n      this.setupDraggableCircle(state);\n      this.addEventListeners(state);\n    } catch (error) {\n      console.error(`Error loading SVG (${this.svgSource}):`, error);\n    }\n  }\n\n  // Cleanup previous SVG's elements and state\n  cleanupPreviousSVG(state: any) {\n    if (state.circle) {\n      state.svg?.removeChild(state.circle);\n      state.circle = null;\n    }\n\n    const indicators = state.svg?.querySelectorAll('.lido-flow-indicator') as NodeListOf<SVGPolygonElement>;\n    indicators.forEach(indicator => {\n      indicator.remove(); // Remove all previous flow indicators\n    });\n\n    state.currentPathIndex = 0;\n    state.lastLength = 0;\n    state.totalPathLength = state.paths[0].getTotalLength();\n  }\n\n  // Move to the next path in the SVG\n  moveToNextPath(state: any) {\n    state.isDragging = false;\n    state.currentPathIndex++;\n    state.lastLength = 0;\n\n    if (state.currentPathIndex >= state.paths.length) {\n      //  this.loadAnotherSVG(state, true);\n      triggerNextContainer();\n      return;\n    }\n\n    const nextPath = state.paths[state.currentPathIndex];\n    if (!nextPath) {\n      console.error('No valid path found at the next index');\n      return;\n    }\n\n    state.totalPathLength = nextPath.getTotalLength();\n\n    const startPoint = nextPath.getPointAtLength(0);\n    state.circle?.setAttribute('cx', startPoint.x.toString());\n    state.circle?.setAttribute('cy', startPoint.y.toString());\n\n    if (state.mode === TraceMode.ShowFlow) {\n      state.flowMarkers = this.createFlowMarkersForPath(nextPath);\n    }\n  }\n\n  render() {\n    const style = {\n      height: this.height,\n      width: this.width,\n      top: this.y,\n      left: this.x,\n      zIndex: this.z,\n      position: 'absolute' as const,\n    };\n\n    // List of SVG file names to process sequentially\n    // const svgFiles = ['A_test.svg', 'B_test.svg', 'C_test.svg', 'D_test.svg', 'à¤…_test.svg', 'à¤Ÿ_test.svg', 'à¤•_test.svg', 'à¤–_test.svg', 'à¤—_test.svg']; // Add more SVG file names as needed\n\n    return (\n      <Host class=\"lido-trace\" id={this.id} style={style} aria-label={this.ariaLabel} aria-hidden={this.ariaHidden} tabindex={this.tabIndex}>\n        <div id=\"lido-svgContainer\"></div>\n      </Host>\n    );\n  }\n}\n",".lido-wrap {\n  display: grid;\n  grid-gap: 10px;\n  grid-template-columns: repeat(auto-fill, minmax(186px, auto));\n}\n\n.lido-wrap > * {\n  padding: 10px;\n  background-color: var(--child-bg-color, #f0f0f0);\n  box-sizing: border-box;\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { initEventsForElement } from '../../utils/utils';\n\n/**\n * @component LidoWrap\n *\n * The `LidoWrap` component acts as a flexible container that supports dynamic positioning, sizing, and layout.\n * The component can display its content as a grid and supports custom events like touch, match, and entry.\n * It allows for full customization via props like dimensions, background color, visibility, and z-index.\n */\n@Component({\n  tag: 'lido-wrap',\n  styleUrl: 'lido-wrap.css',\n  shadow: false,\n})\nexport class LidoWrap {\n  /**\n   * Unique identifier for the wrap element.\n   */\n  @Prop() id: string;\n\n  /**\n   * Value associated with the wrap element, typically used for internal logic or tracking.\n   */\n  @Prop() value: string;\n\n  /**\n   * The height of the wrap container (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() height: string;\n\n  /**\n   * The width of the wrap container (CSS value, e.g., '100px', '50%').\n   */\n  @Prop() width: string;\n\n  /**\n   * The ARIA label of the container. Used for accessibility to indicate the purpose of the element.\n   */\n  @Prop() ariaLabel: string;\n\n  /**\n   * The ARIA hidden attribute of the container. Used for accessibility to hide the element.\n   */\n  @Prop() ariaHidden: string;\n\n  /**\n   * X-axis (horizontal) position of the wrap container (CSS value, e.g., '10px', '5vw').\n   */\n  @Prop() x: string;\n\n  /**\n   * Y-axis (vertical) position of the wrap container (CSS value, e.g., '10px', '5vh').\n   */\n  @Prop() y: string;\n\n  /**\n   * Z-index for stacking order of the wrap container relative to other elements.\n   */\n  @Prop() z: string;\n\n  /**\n   * Background color of the wrap container (CSS color value, e.g., '#FFFFFF', 'blue').\n   */\n  @Prop() bgColor: string;\n\n  /**\n   * Defines the type of the wrap container, which can be used for conditional logic or specific styling.\n   */\n  @Prop() type: string;\n\n  /**\n   * Tab index for keyboard navigation.\n   */\n  @Prop() tabIndex: number;\n\n  /**\n   * Controls the visibility of the wrap container. If `true`, the container is visible; otherwise, it is hidden.\n   */\n  @Prop() visible: boolean;\n\n  /**\n   * URL or identifier of an audio file associated with the wrap container.\n   */\n  @Prop() audio: string;\n\n  /**\n   * Event handler triggered when the wrap container is touched or clicked.\n   */\n  @Prop() onTouch: string;\n\n  /**\n   * Event handler for an Incorrect matching action, which can be used to trigger custom logic when the action is incorrect.\n   */\n  @Prop() onInCorrect: string;\n\n  /**\n   * Event handler for a Correct matching action, which can be used to hide the column or trigger other custom logic.\n   */\n  @Prop() onCorrect: string;\n\n  /**\n   * Event handler triggered when the wrap container is entered (useful for animations or logic on entry).\n   */\n  @Prop() onEntry: string;\n\n  /**\n   * Reference to the HTML element representing this `lido-wrap` component.\n   */\n  @Element() el: HTMLElement;\n\n  /**\n   * Lifecycle hook that runs after the component is rendered in the DOM.\n   * It initializes custom events based on the `type` of the wrap container.\n   */\n  componentDidLoad() {\n    initEventsForElement(this.el, this.type);\n  }\n\n  render() {\n    // Inline styles to position and size the wrap container, with grid layout applied\n    const style = {\n      height: this.height,\n      width: this.width,\n      top: this.y,\n      left: this.x,\n      display: this.visible ? 'grid' : 'none', // Use grid layout\n      zIndex: this.z,\n      backgroundColor: this.bgColor,\n    };\n\n    return (\n      <Host\n        class=\"lido-wrap\"\n        value={this.value}\n        type={this.type}\n        tabindex={this.tabIndex}\n        style={style}\n        aria-label={this.ariaLabel}\n        aria-hidden={this.ariaHidden}\n        audio={this.audio}\n        onTouch={this.onTouch}\n        onCorrect={this.onCorrect}\n        onInCorrect={this.onInCorrect}\n        onEntry={this.onEntry}\n      >\n        {/* Slot for child elements */}\n        <slot />\n      </Host>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}